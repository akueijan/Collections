"use strict";var _extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},__filters=function(e,d){var t,n,r="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",o=((n=d.Filter)&&(w.__proto__=n),((w.prototype=Object.create(n&&n.prototype)).constructor=w).prototype.apply=function(e,t,n,r){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,t,n,r)},w),h=function(r){function e(e,t,n){void 0===e&&(e=4),void 0===t&&(t=3),void 0===n&&(n=!1),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",n?"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n":"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}"),this.uniforms.uOffset=new Float32Array(2),this._pixelSize=new d.Point,this.pixelSize=1,this._clamp=n,this._kernels=null,Array.isArray(e)?this.kernels=e:(this._blur=e,this.quality=t)}r&&(e.__proto__=r);var t={kernels:{configurable:!0},clamp:{configurable:!0},pixelSize:{configurable:!0},quality:{configurable:!0},blur:{configurable:!0}};return((e.prototype=Object.create(r&&r.prototype)).constructor=e).prototype.apply=function(e,t,n,r){var o,i=this.pixelSize.x/t.size.width,a=this.pixelSize.y/t.size.height;if(1===this._quality||0===this._blur)o=this._kernels[0]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*a,e.applyFilter(this,t,n,r);else{for(var l,s=e.getRenderTarget(!0),u=t,c=s,f=this._quality-1,d=0;d<f;d++)o=this._kernels[d]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*a,e.applyFilter(this,u,c,!0),l=u,u=c,c=l;o=this._kernels[f]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*a,e.applyFilter(this,u,n,r),e.returnRenderTarget(s)}},e.prototype._generateKernels=function(){var e=this._blur,t=this._quality,n=[e];if(0<e)for(var r=e,o=e/t,i=1;i<t;i++)r-=o,n.push(r);this._kernels=n},t.kernels.get=function(){return this._kernels},t.kernels.set=function(e){Array.isArray(e)&&0<e.length?(this._kernels=e,this._quality=e.length,this._blur=Math.max.apply(Math,e)):(this._kernels=[0],this._quality=1)},t.clamp.get=function(){return this._clamp},t.pixelSize.set=function(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof d.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)},t.pixelSize.get=function(){return this._pixelSize},t.quality.get=function(){return this._quality},t.quality.set=function(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()},t.blur.get=function(){return this._blur},t.blur.set=function(e){this._blur=e,this._generateKernels()},Object.defineProperties(e.prototype,t),e}(d.Filter),l=r,s=function(t){function e(e){void 0===e&&(e=.5),t.call(this,l,"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n"),this.threshold=e}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={threshold:{configurable:!0}};return n.threshold.get=function(){return this.uniforms.threshold},n.threshold.set=function(e){this.uniforms.threshold=e},Object.defineProperties(e.prototype,n),e}(d.Filter),i=function(a){function e(e){a.call(this,l,"uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n"),"number"==typeof e&&(e={threshold:e}),e=_extends({threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:d.settings.RESOLUTION},e),this.bloomScale=e.bloomScale,this.brightness=e.brightness;var t=e.kernels,n=e.blur,r=e.quality,o=e.pixelSize,i=e.resolution;this._extractFilter=new s(e.threshold),this._extractFilter.resolution=i,this._blurFilter=t?new h(t):new h(n,r),this.pixelSize=o,this.resolution=i}a&&(e.__proto__=a);var t={resolution:{configurable:!0},threshold:{configurable:!0},kernels:{configurable:!0},blur:{configurable:!0},quality:{configurable:!0},pixelSize:{configurable:!0}};return((e.prototype=Object.create(a&&a.prototype)).constructor=e).prototype.apply=function(e,t,n,r,o){var i=e.getRenderTarget(!0);this._extractFilter.apply(e,t,i,!0,o);var a=e.getRenderTarget(!0);this._blurFilter.apply(e,i,a,!0,o),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=a,e.applyFilter(this,t,n,r),e.returnRenderTarget(a),e.returnRenderTarget(i)},t.resolution.get=function(){return this._resolution},t.resolution.set=function(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},t.threshold.get=function(){return this._extractFilter.threshold},t.threshold.set=function(e){this._extractFilter.threshold=e},t.kernels.get=function(){return this._blurFilter.kernels},t.kernels.set=function(e){this._blurFilter.kernels=e},t.blur.get=function(){return this._blurFilter.blur},t.blur.set=function(e){this._blurFilter.blur=e},t.quality.get=function(){return this._blurFilter.quality},t.quality.set=function(e){this._blurFilter.quality=e},t.pixelSize.get=function(){return this._blurFilter.pixelSize},t.pixelSize.set=function(e){this._blurFilter.pixelSize=e},Object.defineProperties(e.prototype,t),e}(d.Filter),a=function(t){function e(e){void 0===e&&(e=8),t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n    {\n        if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}"),this.size=e}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={size:{configurable:!0}};return n.size.get=function(){return this.uniforms.pixelSize},n.size.set=function(e){this.uniforms.pixelSize=e},Object.defineProperties(e.prototype,n),e}(d.Filter),u=function(t){function e(e){void 0===e&&(e={}),t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n"),this.uniforms.lightColor=new Float32Array(3),this.uniforms.shadowColor=new Float32Array(3),e=_extends({rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},e),this.rotation=e.rotation,this.thickness=e.thickness,this.lightColor=e.lightColor,this.lightAlpha=e.lightAlpha,this.shadowColor=e.shadowColor,this.shadowAlpha=e.shadowAlpha}t&&(e.__proto__=t);var n={rotation:{configurable:!0},thickness:{configurable:!0},lightColor:{configurable:!0},lightAlpha:{configurable:!0},shadowColor:{configurable:!0},shadowAlpha:{configurable:!0}};return((e.prototype=Object.create(t&&t.prototype)).constructor=e).prototype._updateTransform=function(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)},n.rotation.get=function(){return this._angle/d.DEG_TO_RAD},n.rotation.set=function(e){this._angle=e*d.DEG_TO_RAD,this._updateTransform()},n.thickness.get=function(){return this._thickness},n.thickness.set=function(e){this._thickness=e,this._updateTransform()},n.lightColor.get=function(){return d.utils.rgb2hex(this.uniforms.lightColor)},n.lightColor.set=function(e){d.utils.hex2rgb(e,this.uniforms.lightColor)},n.lightAlpha.get=function(){return this.uniforms.lightAlpha},n.lightAlpha.set=function(e){this.uniforms.lightAlpha=e},n.shadowColor.get=function(){return d.utils.rgb2hex(this.uniforms.shadowColor)},n.shadowColor.set=function(e){d.utils.hex2rgb(e,this.uniforms.shadowColor)},n.shadowAlpha.get=function(){return this.uniforms.shadowAlpha},n.shadowAlpha.set=function(e){this.uniforms.shadowAlpha=e},Object.defineProperties(e.prototype,n),e}(d.Filter),c=d.filters,f=c.BlurXFilter,m=c.BlurYFilter,p=c.AlphaFilter,g=function(a){function e(e,t,n,r){var o,i;void 0===e&&(e=2),void 0===t&&(t=4),void 0===n&&(n=d.settings.RESOLUTION),void 0===r&&(r=5),a.call(this),"number"==typeof e?i=o=e:e instanceof d.Point?(o=e.x,i=e.y):Array.isArray(e)&&(o=e[0],i=e[1]),this.blurXFilter=new f(o,t,n,r),this.blurYFilter=new m(i,t,n,r),this.blurYFilter.blendMode=d.BLEND_MODES.SCREEN,this.defaultFilter=new p}a&&(e.__proto__=a);var t={blur:{configurable:!0},blurX:{configurable:!0},blurY:{configurable:!0}};return((e.prototype=Object.create(a&&a.prototype)).constructor=e).prototype.apply=function(e,t,n){var r=e.getRenderTarget(!0);this.defaultFilter.apply(e,t,n),this.blurXFilter.apply(e,t,r),this.blurYFilter.apply(e,r,n),e.returnRenderTarget(r)},t.blur.get=function(){return this.blurXFilter.blur},t.blur.set=function(e){this.blurXFilter.blur=this.blurYFilter.blur=e},t.blurX.get=function(){return this.blurXFilter.blur},t.blurX.set=function(e){this.blurXFilter.blur=e},t.blurY.get=function(){return this.blurYFilter.blur},t.blurY.set=function(e){this.blurYFilter.blur=e},Object.defineProperties(e.prototype,t),e}(d.Filter),v=function(r){function e(e,t,n){r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n"),this.uniforms.dimensions=new Float32Array(2),this.center=e||[.5,.5],this.radius="number"==typeof t?t:100,this.strength="number"==typeof n?n:1}r&&(e.__proto__=r);var t={radius:{configurable:!0},strength:{configurable:!0},center:{configurable:!0}};return((e.prototype=Object.create(r&&r.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,e.applyFilter(this,t,n,r)},t.radius.get=function(){return this.uniforms.radius},t.radius.set=function(e){this.uniforms.radius=e},t.strength.get=function(){return this.uniforms.strength},t.strength.set=function(e){this.uniforms.strength=e},t.center.get=function(){return this.uniforms.center},t.center.set=function(e){this.uniforms.center=e},Object.defineProperties(e.prototype,t),e}(d.Filter),x=function(r){function e(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=1),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}"),this._size=0,this._sliceSize=0,this._slicePixelSize=0,this._sliceInnerSize=0,this._scaleMode=null,this._nearest=!1,this.nearest=t,this.mix=n,this.colorMap=e}r&&(e.__proto__=r);var t={colorSize:{configurable:!0},colorMap:{configurable:!0},nearest:{configurable:!0}};return((e.prototype=Object.create(r&&r.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms._mix=this.mix,e.applyFilter(this,t,n,r)},t.colorSize.get=function(){return this._size},t.colorMap.get=function(){return this._colorMap},t.colorMap.set=function(e){e instanceof d.Texture||(e=d.Texture.from(e)),e&&e.baseTexture&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=!1,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e},t.nearest.get=function(){return this._nearest},t.nearest.set=function(e){this._nearest=e,this._scaleMode=e?d.SCALE_MODES.NEAREST:d.SCALE_MODES.LINEAR;var t=this._colorMap;t&&t.baseTexture&&(t.baseTexture._glTextures={},t.baseTexture.scaleMode=this._scaleMode,t.baseTexture.mipmap=!1,t._updateID++,t.baseTexture.emit("update",t.baseTexture))},e.prototype.updateColorMap=function(){var e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)},e.prototype.destroy=function(e){this._colorMap&&this._colorMap.destroy(e),r.prototype.destroy.call(this)},Object.defineProperties(e.prototype,t),e}(d.Filter),y=function(r){function e(e,t,n){void 0===e&&(e=16711680),void 0===t&&(t=0),void 0===n&&(n=.4),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n"),this.uniforms.originalColor=new Float32Array(3),this.uniforms.newColor=new Float32Array(3),this.originalColor=e,this.newColor=t,this.epsilon=n}r&&(e.__proto__=r),(e.prototype=Object.create(r&&r.prototype)).constructor=e;var t={originalColor:{configurable:!0},newColor:{configurable:!0},epsilon:{configurable:!0}};return t.originalColor.set=function(e){var t=this.uniforms.originalColor;"number"==typeof e?(d.utils.hex2rgb(e,t),this._originalColor=e):(t[0]=e[0],t[1]=e[1],t[2]=e[2],this._originalColor=d.utils.rgb2hex(t))},t.originalColor.get=function(){return this._originalColor},t.newColor.set=function(e){var t=this.uniforms.newColor;"number"==typeof e?(d.utils.hex2rgb(e,t),this._newColor=e):(t[0]=e[0],t[1]=e[1],t[2]=e[2],this._newColor=d.utils.rgb2hex(t))},t.newColor.get=function(){return this._newColor},t.epsilon.set=function(e){this.uniforms.epsilon=e},t.epsilon.get=function(){return this.uniforms.epsilon},Object.defineProperties(e.prototype,t),e}(d.Filter),b=function(r){function e(e,t,n){void 0===t&&(t=200),void 0===n&&(n=200),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n"),this.uniforms.texelSize=new Float32Array(2),this.uniforms.matrix=new Float32Array(9),void 0!==e&&(this.matrix=e),this.width=t,this.height=n}r&&(e.__proto__=r),(e.prototype=Object.create(r&&r.prototype)).constructor=e;var t={matrix:{configurable:!0},width:{configurable:!0},height:{configurable:!0}};return t.matrix.get=function(){return this.uniforms.matrix},t.matrix.set=function(e){var n=this;e.forEach(function(e,t){return n.uniforms.matrix[t]=e})},t.width.get=function(){return 1/this.uniforms.texelSize[0]},t.width.set=function(e){this.uniforms.texelSize[0]=1/e},t.height.get=function(){return 1/this.uniforms.texelSize[1]},t.height.set=function(e){this.uniforms.texelSize[1]=1/e},Object.defineProperties(e.prototype,t),e}(d.Filter),_=((t=d.Filter)&&(A.__proto__=t),(A.prototype=Object.create(t&&t.prototype)).constructor=A),C=function(t){function e(e){t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    vec2 dir = vec2(coord - vec2(0.5, 0.5));\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0) {\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n"),this.uniforms.dimensions=new Float32Array(2),this.time=0,this.seed=0,_extends(this,{curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0},e)}t&&(e.__proto__=t);var n={curvature:{configurable:!0},lineWidth:{configurable:!0},lineContrast:{configurable:!0},verticalLine:{configurable:!0},noise:{configurable:!0},noiseSize:{configurable:!0},vignetting:{configurable:!0},vignettingAlpha:{configurable:!0},vignettingBlur:{configurable:!0}};return((e.prototype=Object.create(t&&t.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},n.curvature.set=function(e){this.uniforms.curvature=e},n.curvature.get=function(){return this.uniforms.curvature},n.lineWidth.set=function(e){this.uniforms.lineWidth=e},n.lineWidth.get=function(){return this.uniforms.lineWidth},n.lineContrast.set=function(e){this.uniforms.lineContrast=e},n.lineContrast.get=function(){return this.uniforms.lineContrast},n.verticalLine.set=function(e){this.uniforms.verticalLine=e},n.verticalLine.get=function(){return this.uniforms.verticalLine},n.noise.set=function(e){this.uniforms.noise=e},n.noise.get=function(){return this.uniforms.noise},n.noiseSize.set=function(e){this.uniforms.noiseSize=e},n.noiseSize.get=function(){return this.uniforms.noiseSize},n.vignetting.set=function(e){this.uniforms.vignetting=e},n.vignetting.get=function(){return this.uniforms.vignetting},n.vignettingAlpha.set=function(e){this.uniforms.vignettingAlpha=e},n.vignettingAlpha.get=function(){return this.uniforms.vignettingAlpha},n.vignettingBlur.set=function(e){this.uniforms.vignettingBlur=e},n.vignettingBlur.get=function(){return this.uniforms.vignettingBlur},Object.defineProperties(e.prototype,n),e}(d.Filter),S=function(n){function e(e,t){void 0===e&&(e=1),void 0===t&&(t=5),n.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n"),this.scale=e,this.angle=t}n&&(e.__proto__=n),(e.prototype=Object.create(n&&n.prototype)).constructor=e;var t={scale:{configurable:!0},angle:{configurable:!0}};return t.scale.get=function(){return this.uniforms.scale},t.scale.set=function(e){this.uniforms.scale=e},t.angle.get=function(){return this.uniforms.angle},t.angle.set=function(e){this.uniforms.angle=e},Object.defineProperties(e.prototype,t),e}(d.Filter),T=function(f){function e(e){e&&e.constructor!==Object&&(console.warn("DropShadowFilter now uses options instead of (rotation, distance, blur, color, alpha)"),e={rotation:e},void 0!==arguments[1]&&(e.distance=arguments[1]),void 0!==arguments[2]&&(e.blur=arguments[2]),void 0!==arguments[3]&&(e.color=arguments[3]),void 0!==arguments[4]&&(e.alpha=arguments[4])),e=_extends({rotation:45,distance:5,color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:d.settings.RESOLUTION},e),f.call(this);var t=e.kernels,n=e.blur,r=e.quality,o=e.pixelSize,i=e.resolution;this._tintFilter=new d.Filter("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n\n    // Un-premultiply alpha before applying the color\n    if (sample.a > 0.0) {\n        sample.rgb /= sample.a;\n    }\n\n    // Premultiply alpha again\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),this._tintFilter.uniforms.color=new Float32Array(4),this._tintFilter.resolution=i,this._blurFilter=t?new h(t):new h(n,r),this.pixelSize=o,this.resolution=i,this.targetTransform=new d.Matrix;var a=e.shadowOnly,l=e.rotation,s=e.distance,u=e.alpha,c=e.color;this.shadowOnly=a,this.rotation=l,this.distance=s,this.alpha=u,this.color=c,this._updatePadding()}f&&(e.__proto__=f);var t={resolution:{configurable:!0},distance:{configurable:!0},rotation:{configurable:!0},alpha:{configurable:!0},color:{configurable:!0},kernels:{configurable:!0},blur:{configurable:!0},quality:{configurable:!0},pixelSize:{configurable:!0}};return((e.prototype=Object.create(f&&f.prototype)).constructor=e).prototype.apply=function(e,t,n,r){var o=e.getRenderTarget();o.transform=this.targetTransform,this._tintFilter.apply(e,t,o,!0),o.transform=null,this._blurFilter.apply(e,o,n,r),!0!==this.shadowOnly&&e.applyFilter(this,t,n,!1),e.returnRenderTarget(o)},e.prototype._updatePadding=function(){this.padding=this.distance+2*this.blur},e.prototype._updateTargetTransform=function(){this.targetTransform.tx=this.distance*Math.cos(this.angle),this.targetTransform.ty=this.distance*Math.sin(this.angle)},t.resolution.get=function(){return this._resolution},t.resolution.set=function(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},t.distance.get=function(){return this._distance},t.distance.set=function(e){this._distance=e,this._updatePadding(),this._updateTargetTransform()},t.rotation.get=function(){return this.angle/d.DEG_TO_RAD},t.rotation.set=function(e){this.angle=e*d.DEG_TO_RAD,this._updateTargetTransform()},t.alpha.get=function(){return this._tintFilter.uniforms.alpha},t.alpha.set=function(e){this._tintFilter.uniforms.alpha=e},t.color.get=function(){return d.utils.rgb2hex(this._tintFilter.uniforms.color)},t.color.set=function(e){d.utils.hex2rgb(e,this._tintFilter.uniforms.color)},t.kernels.get=function(){return this._blurFilter.kernels},t.kernels.set=function(e){this._blurFilter.kernels=e},t.blur.get=function(){return this._blurFilter.blur},t.blur.set=function(e){this._blurFilter.blur=e,this._updatePadding()},t.quality.get=function(){return this._blurFilter.quality},t.quality.set=function(e){this._blurFilter.quality=e},t.pixelSize.get=function(){return this._blurFilter.pixelSize},t.pixelSize.set=function(e){this._blurFilter.pixelSize=e},Object.defineProperties(e.prototype,t),e}(d.Filter),F=function(t){function e(e){void 0===e&&(e=5),t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n"),this.strength=e}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={strength:{configurable:!0}};return n.strength.get=function(){return this.uniforms.strength},n.strength.set=function(e){this.uniforms.strength=e},Object.defineProperties(e.prototype,n),e}(d.Filter),z=function(t){function e(e){void 0===e&&(e={}),t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == ORIGINAL) {\n                gl_FragColor = texture2D(uSampler, vTextureCoord);\n                return;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            } else {\n                gl_FragColor = vec4(0., 0., 0., 0.);\n                return;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n"),this.uniforms.dimensions=new Float32Array(2),e=_extends({slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},e),this.direction=e.direction,this.red=e.red,this.green=e.green,this.blue=e.blue,this.offset=e.offset,this.fillMode=e.fillMode,this.average=e.average,this.seed=e.seed,this.minSize=e.minSize,this.sampleSize=e.sampleSize,this._canvas=document.createElement("canvas"),this._canvas.width=4,this._canvas.height=this.sampleSize,this.texture=d.Texture.fromCanvas(this._canvas,d.SCALE_MODES.NEAREST),this._slices=0,this.slices=e.slices}t&&(e.__proto__=t);var n={sizes:{configurable:!0},offsets:{configurable:!0},slices:{configurable:!0},direction:{configurable:!0},red:{configurable:!0},green:{configurable:!0},blue:{configurable:!0}};return((e.prototype=Object.create(t&&t.prototype)).constructor=e).prototype.apply=function(e,t,n,r){var o=t.sourceFrame.width,i=t.sourceFrame.height;this.uniforms.dimensions[0]=o,this.uniforms.dimensions[1]=i,this.uniforms.aspect=i/o,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,t,n,r)},e.prototype._randomizeSizes=function(){var e=this._sizes,t=this._slices-1,n=this.sampleSize,r=Math.min(this.minSize/n,.9/this._slices);if(this.average){for(var o=this._slices,i=1,a=0;a<t;a++){var l=i/(o-a),s=Math.max(l*(1-.6*Math.random()),r);i-=e[a]=s}e[t]=i}else{for(var u=1,c=Math.sqrt(1/this._slices),f=0;f<t;f++){var d=Math.max(c*u*Math.random(),r);u-=e[f]=d}e[t]=u}this.shuffle()},e.prototype.shuffle=function(){for(var e=this._sizes,t=this._slices-1;0<t;t--){var n=Math.random()*t>>0,r=e[t];e[t]=e[n],e[n]=r}},e.prototype._randomizeOffsets=function(){for(var e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)},e.prototype.refresh=function(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()},e.prototype.redraw=function(){var e,t=this.sampleSize,n=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,t);for(var o=0,i=0;i<this._slices;i++){e=Math.floor(256*this._offsets[i]);var a=this._sizes[i]*t,l=0<e?e:0,s=e<0?-e:0;r.fillStyle="rgba("+l+", "+s+", 0, 1)",r.fillRect(0,o>>0,t,1+a>>0),o+=a}n.baseTexture.update(),this.uniforms.displacementMap=n},n.sizes.set=function(e){for(var t=Math.min(this._slices,e.length),n=0;n<t;n++)this._sizes[n]=e[n]},n.sizes.get=function(){return this._sizes},n.offsets.set=function(e){for(var t=Math.min(this._slices,e.length),n=0;n<t;n++)this._offsets[n]=e[n]},n.offsets.get=function(){return this._offsets},n.slices.get=function(){return this._slices},n.slices.set=function(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())},n.direction.get=function(){return this._direction},n.direction.set=function(e){if(this._direction!==e){var t=(this._direction=e)*d.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(t),this.uniforms.cosDir=Math.cos(t)}},n.red.get=function(){return this.uniforms.red},n.red.set=function(e){this.uniforms.red=e},n.green.get=function(){return this.uniforms.green},n.green.set=function(e){this.uniforms.green=e},n.blue.get=function(){return this.uniforms.blue},n.blue.set=function(e){this.uniforms.blue=e},e.prototype.destroy=function(){this.texture.destroy(!0),this.texture=null,this._canvas=null,this.red=null,this.green=null,this.blue=null,this._sizes=null,this._offsets=null},Object.defineProperties(e.prototype,n),e}(d.Filter);function A(){t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n")}function w(e){n.call(this,r,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n"),_extends(this,{gamma:1,saturation:1,contrast:1,brightness:1,red:1,green:1,blue:1,alpha:1},e)}z.TRANSPARENT=0,z.ORIGINAL=1,z.LOOP=2,z.CLAMP=3,z.MIRROR=4;var P=function(i){function e(e,t,n,r,o){void 0===e&&(e=10),void 0===t&&(t=4),void 0===n&&(n=0),void 0===r&&(r=16777215),void 0===o&&(o=.1),i.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float distance;\nuniform float outerStrength;\nuniform float innerStrength;\nuniform vec4 glowColor;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nconst float PI = 3.14159265358979323846264;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float totalAlpha = 0.0;\n    float maxTotalAlpha = 0.0;\n    float cosAngle;\n    float sinAngle;\n    vec2 displaced;\n    for (float angle = 0.0; angle <= PI * 2.0; angle += %QUALITY_DIST%) {\n       cosAngle = cos(angle);\n       sinAngle = sin(angle);\n       for (float curDistance = 1.0; curDistance <= %DIST%; curDistance++) {\n           displaced.x = vTextureCoord.x + cosAngle * curDistance * px.x;\n           displaced.y = vTextureCoord.y + sinAngle * curDistance * px.y;\n           curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n           totalAlpha += (distance - curDistance) * curColor.a;\n           maxTotalAlpha += (distance - curDistance);\n       }\n    }\n    maxTotalAlpha = max(maxTotalAlpha, 0.0001);\n\n    ownColor.a = max(ownColor.a, 0.0001);\n    ownColor.rgb = ownColor.rgb / ownColor.a;\n    float outerGlowAlpha = (totalAlpha / maxTotalAlpha)  * outerStrength * (1. - ownColor.a);\n    float innerGlowAlpha = ((maxTotalAlpha - totalAlpha) / maxTotalAlpha) * innerStrength * ownColor.a;\n    float resultAlpha = (ownColor.a + outerGlowAlpha);\n    gl_FragColor = vec4(mix(mix(ownColor.rgb, glowColor.rgb, innerGlowAlpha / ownColor.a), glowColor.rgb, outerGlowAlpha / resultAlpha) * resultAlpha, resultAlpha);\n}\n".replace(/%QUALITY_DIST%/gi,""+(1/o/e).toFixed(7)).replace(/%DIST%/gi,""+e.toFixed(7))),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.distance=e,this.color=r,this.outerStrength=t,this.innerStrength=n}i&&(e.__proto__=i),(e.prototype=Object.create(i&&i.prototype)).constructor=e;var t={color:{configurable:!0},distance:{configurable:!0},outerStrength:{configurable:!0},innerStrength:{configurable:!0}};return t.color.get=function(){return d.utils.rgb2hex(this.uniforms.glowColor)},t.color.set=function(e){d.utils.hex2rgb(e,this.uniforms.glowColor)},t.distance.get=function(){return this.uniforms.distance},t.distance.set=function(e){this.uniforms.distance=e},t.outerStrength.get=function(){return this.uniforms.outerStrength},t.outerStrength.set=function(e){this.uniforms.outerStrength=e},t.innerStrength.get=function(){return this.uniforms.innerStrength},t.innerStrength.set=function(e){this.uniforms.innerStrength=e},Object.defineProperties(e.prototype,t),e}(d.Filter),D=function(t){function e(e){t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n}\n".replace("${perlin}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n")),this.uniforms.dimensions=new Float32Array(2),"number"==typeof e&&(console.warn("GodrayFilter now uses options instead of (angle, gain, lacunarity, time)"),e={angle:e},void 0!==arguments[1]&&(e.gain=arguments[1]),void 0!==arguments[2]&&(e.lacunarity=arguments[2]),void 0!==arguments[3]&&(e.time=arguments[3])),e=_extends({angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0]},e),this._angleLight=new d.Point,this.angle=e.angle,this.gain=e.gain,this.lacunarity=e.lacunarity,this.parallel=e.parallel,this.center=e.center,this.time=e.time}t&&(e.__proto__=t);var n={angle:{configurable:!0},gain:{configurable:!0},lacunarity:{configurable:!0}};return((e.prototype=Object.create(t&&t.prototype)).constructor=e).prototype.apply=function(e,t,n,r){var o=t.sourceFrame,i=o.width,a=o.height;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=a,this.uniforms.aspect=a/i,this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},n.angle.get=function(){return this._angle},n.angle.set=function(e){var t=(this._angle=e)*d.DEG_TO_RAD;this._angleLight.x=Math.cos(t),this._angleLight.y=Math.sin(t)},n.gain.get=function(){return this.uniforms.gain},n.gain.set=function(e){this.uniforms.gain=e},n.lacunarity.get=function(){return this.uniforms.lacunarity},n.lacunarity.set=function(e){this.uniforms.lacunarity=e},Object.defineProperties(e.prototype,n),e}(d.Filter),M=function(r){function e(e,t,n){void 0===e&&(e=[0,0]),void 0===t&&(t=5),void 0===n&&(n=0),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n"),this.uniforms.uVelocity=new Float32Array(2),this._velocity=new d.ObservablePoint(this.velocityChanged,this),this.velocity=e,this.kernelSize=t,this.offset=n}r&&(e.__proto__=r);var t={velocity:{configurable:!0},offset:{configurable:!0}};return((e.prototype=Object.create(r&&r.prototype)).constructor=e).prototype.apply=function(e,t,n,r){var o=this.velocity,i=o.x,a=o.y;this.uniforms.uKernelSize=0!==i||0!==a?this.kernelSize:0,e.applyFilter(this,t,n,r)},t.velocity.set=function(e){Array.isArray(e)?this._velocity.set(e[0],e[1]):(e instanceof d.Point||e instanceof d.ObservablePoint)&&this._velocity.copy(e)},t.velocity.get=function(){return this._velocity},e.prototype.velocityChanged=function(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y},t.offset.set=function(e){this.uniforms.uOffset=e},t.offset.get=function(){return this.uniforms.uOffset},Object.defineProperties(e.prototype,t),e}(d.Filter),O=function(r){function e(e,t,n){void 0===t&&(t=.05),void 0===n&&(n=null),n=n||e.length,r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n".replace(/%maxColors%/g,n)),this.epsilon=t,this._maxColors=n,this._replacements=null,this.uniforms.originalColors=new Float32Array(3*n),this.uniforms.targetColors=new Float32Array(3*n),this.replacements=e}r&&(e.__proto__=r),(e.prototype=Object.create(r&&r.prototype)).constructor=e;var t={replacements:{configurable:!0},maxColors:{configurable:!0},epsilon:{configurable:!0}};return t.replacements.set=function(e){var t=this.uniforms.originalColors,n=this.uniforms.targetColors,r=e.length;if(r>this._maxColors)throw"Length of replacements ("+r+") exceeds the maximum colors length ("+this._maxColors+")";t[3*r]=-1;for(var o=0;o<r;o++){var i=e[o],a=i[0];"number"==typeof a?a=d.utils.hex2rgb(a):i[0]=d.utils.rgb2hex(a),t[3*o]=a[0],t[3*o+1]=a[1],t[3*o+2]=a[2];var l=i[1];"number"==typeof l?l=d.utils.hex2rgb(l):i[1]=d.utils.rgb2hex(l),n[3*o]=l[0],n[3*o+1]=l[1],n[3*o+2]=l[2]}this._replacements=e},t.replacements.get=function(){return this._replacements},e.prototype.refresh=function(){this.replacements=this._replacements},t.maxColors.get=function(){return this._maxColors},t.epsilon.set=function(e){this.uniforms.epsilon=e},t.epsilon.get=function(){return this.uniforms.epsilon},Object.defineProperties(e.prototype,t),e}(d.Filter),j=function(n){function e(e,t){void 0===t&&(t=0),n.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n"),this.uniforms.dimensions=new Float32Array(2),"number"==typeof e?(this.seed=e,e=null):this.seed=t,_extends(this,{sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3},e)}n&&(e.__proto__=n);var t={sepia:{configurable:!0},noise:{configurable:!0},noiseSize:{configurable:!0},scratch:{configurable:!0},scratchDensity:{configurable:!0},scratchWidth:{configurable:!0},vignetting:{configurable:!0},vignettingAlpha:{configurable:!0},vignettingBlur:{configurable:!0}};return((e.prototype=Object.create(n&&n.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,this.uniforms.seed=this.seed,e.applyFilter(this,t,n,r)},t.sepia.set=function(e){this.uniforms.sepia=e},t.sepia.get=function(){return this.uniforms.sepia},t.noise.set=function(e){this.uniforms.noise=e},t.noise.get=function(){return this.uniforms.noise},t.noiseSize.set=function(e){this.uniforms.noiseSize=e},t.noiseSize.get=function(){return this.uniforms.noiseSize},t.scratch.set=function(e){this.uniforms.scratch=e},t.scratch.get=function(){return this.uniforms.scratch},t.scratchDensity.set=function(e){this.uniforms.scratchDensity=e},t.scratchDensity.get=function(){return this.uniforms.scratchDensity},t.scratchWidth.set=function(e){this.uniforms.scratchWidth=e},t.scratchWidth.get=function(){return this.uniforms.scratchWidth},t.vignetting.set=function(e){this.uniforms.vignetting=e},t.vignetting.get=function(){return this.uniforms.vignetting},t.vignettingAlpha.set=function(e){this.uniforms.vignettingAlpha=e},t.vignettingAlpha.get=function(){return this.uniforms.vignettingAlpha},t.vignettingBlur.set=function(e){this.uniforms.vignettingBlur=e},t.vignettingBlur.get=function(){return this.uniforms.vignettingBlur},Object.defineProperties(e.prototype,t),e}(d.Filter),R=function(i){function a(e,t,n){void 0===e&&(e=1),void 0===t&&(t=0),void 0===n&&(n=.1);var r=Math.max(n*a.MAX_SAMPLES,a.MIN_SAMPLES),o=(2*Math.PI/r).toFixed(7);i.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n".replace(/\$\{angleStep\}/,o)),this.uniforms.thickness=new Float32Array([0,0]),this.thickness=e,this.uniforms.outlineColor=new Float32Array([0,0,0,1]),this.color=t,this.quality=n}i&&(a.__proto__=i);var e={color:{configurable:!0}};return((a.prototype=Object.create(i&&i.prototype)).constructor=a).prototype.apply=function(e,t,n,r){this.uniforms.thickness[0]=this.thickness/t.size.width,this.uniforms.thickness[1]=this.thickness/t.size.height,e.applyFilter(this,t,n,r)},e.color.get=function(){return d.utils.rgb2hex(this.uniforms.outlineColor)},e.color.set=function(e){d.utils.hex2rgb(e,this.uniforms.outlineColor)},Object.defineProperties(a.prototype,e),a}(d.Filter);R.MIN_SAMPLES=1,R.MAX_SAMPLES=100;var L,k,I=function(t){function e(e){void 0===e&&(e=10),t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n"),this.size=e}t&&(e.__proto__=t),(e.prototype=Object.create(t&&t.prototype)).constructor=e;var n={size:{configurable:!0}};return n.size.get=function(){return this.uniforms.size},n.size.set=function(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e},Object.defineProperties(e.prototype,n),e}(d.Filter),E=function(o){function e(e,t,n,r){void 0===e&&(e=0),void 0===t&&(t=[0,0]),void 0===n&&(n=5),void 0===r&&(r=-1),o.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n"),this._angle=0,this.angle=e,this.center=t,this.kernelSize=n,this.radius=r}o&&(e.__proto__=o);var t={angle:{configurable:!0},center:{configurable:!0},radius:{configurable:!0}};return((e.prototype=Object.create(o&&o.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,t,n,r)},t.angle.set=function(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180},t.angle.get=function(){return this._angle},t.center.get=function(){return this.uniforms.uCenter},t.center.set=function(e){this.uniforms.uCenter=e},t.radius.get=function(){return this.uniforms.uRadius},t.radius.set=function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},Object.defineProperties(e.prototype,t),e}(d.Filter),V=function(t){function e(e){t.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n"),this.uniforms.amplitude=new Float32Array(2),this.uniforms.waveLength=new Float32Array(2),this.uniforms.alpha=new Float32Array(2),this.uniforms.dimensions=new Float32Array(2),_extends(this,{mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0},e)}t&&(e.__proto__=t);var n={mirror:{configurable:!0},boundary:{configurable:!0},amplitude:{configurable:!0},waveLength:{configurable:!0},alpha:{configurable:!0}};return((e.prototype=Object.create(t&&t.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},n.mirror.set=function(e){this.uniforms.mirror=e},n.mirror.get=function(){return this.uniforms.mirror},n.boundary.set=function(e){this.uniforms.boundary=e},n.boundary.get=function(){return this.uniforms.boundary},n.amplitude.set=function(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]},n.amplitude.get=function(){return this.uniforms.amplitude},n.waveLength.set=function(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]},n.waveLength.get=function(){return this.uniforms.waveLength},n.alpha.set=function(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]},n.alpha.get=function(){return this.uniforms.alpha},Object.defineProperties(e.prototype,n),e}(d.Filter),B=function(r){function e(e,t,n){void 0===e&&(e=[-10,0]),void 0===t&&(t=[0,10]),void 0===n&&(n=[0,0]),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n"),this.red=e,this.green=t,this.blue=n}r&&(e.__proto__=r),(e.prototype=Object.create(r&&r.prototype)).constructor=e;var t={red:{configurable:!0},green:{configurable:!0},blue:{configurable:!0}};return t.red.get=function(){return this.uniforms.red},t.red.set=function(e){this.uniforms.red=e},t.green.get=function(){return this.uniforms.green},t.green.set=function(e){this.uniforms.green=e},t.blue.get=function(){return this.uniforms.blue},t.blue.set=function(e){this.uniforms.blue=e},Object.defineProperties(e.prototype,t),e}(d.Filter),X=function(r){function e(e,t,n){void 0===e&&(e=[0,0]),void 0===t&&(t={}),void 0===n&&(n=0),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n"),this.center=e,Array.isArray(t)&&(console.warn("Deprecated Warning: ShockwaveFilter params Array has been changed to options Object."),t={}),t=_extends({amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1},t),this.amplitude=t.amplitude,this.wavelength=t.wavelength,this.brightness=t.brightness,this.speed=t.speed,this.radius=t.radius,this.time=n}r&&(e.__proto__=r);var t={center:{configurable:!0},amplitude:{configurable:!0},wavelength:{configurable:!0},brightness:{configurable:!0},speed:{configurable:!0},radius:{configurable:!0}};return((e.prototype=Object.create(r&&r.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.time=this.time,e.applyFilter(this,t,n,r)},t.center.get=function(){return this.uniforms.center},t.center.set=function(e){this.uniforms.center=e},t.amplitude.get=function(){return this.uniforms.amplitude},t.amplitude.set=function(e){this.uniforms.amplitude=e},t.wavelength.get=function(){return this.uniforms.wavelength},t.wavelength.set=function(e){this.uniforms.wavelength=e},t.brightness.get=function(){return this.uniforms.brightness},t.brightness.set=function(e){this.uniforms.brightness=e},t.speed.get=function(){return this.uniforms.speed},t.speed.set=function(e){this.uniforms.speed=e},t.radius.get=function(){return this.uniforms.radius},t.radius.set=function(e){this.uniforms.radius=e},Object.defineProperties(e.prototype,t),e}(d.Filter),q=function(r){function e(e,t,n){void 0===t&&(t=0),void 0===n&&(n=1),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n"),this.uniforms.dimensions=new Float32Array(2),this.uniforms.ambientColor=new Float32Array([0,0,0,n]),this.texture=e,this.color=t}r&&(e.__proto__=r);var t={texture:{configurable:!0},color:{configurable:!0},alpha:{configurable:!0}};return((e.prototype=Object.create(r&&r.prototype)).constructor=e).prototype.apply=function(e,t,n,r){this.uniforms.dimensions[0]=t.sourceFrame.width,this.uniforms.dimensions[1]=t.sourceFrame.height,e.applyFilter(this,t,n,r)},t.texture.get=function(){return this.uniforms.uLightmap},t.texture.set=function(e){this.uniforms.uLightmap=e},t.color.set=function(e){var t=this.uniforms.ambientColor;"number"==typeof e?(d.utils.hex2rgb(e,t),this._color=e):(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],this._color=d.utils.rgb2hex(t))},t.color.get=function(){return this._color},t.alpha.get=function(){return this.uniforms.ambientColor[3]},t.alpha.set=function(e){this.uniforms.ambientColor[3]=e},Object.defineProperties(e.prototype,t),e}(d.Filter),N=function(o){function e(e,t,n,r){void 0===e&&(e=100),void 0===t&&(t=600),void 0===n&&(n=null),void 0===r&&(r=null),o.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n"),this.uniforms.blur=e,this.uniforms.gradientBlur=t,this.uniforms.start=n||new d.Point(0,window.innerHeight/2),this.uniforms.end=r||new d.Point(600,window.innerHeight/2),this.uniforms.delta=new d.Point(30,30),this.uniforms.texSize=new d.Point(window.innerWidth,window.innerHeight),this.updateDelta()}o&&(e.__proto__=o);var t={blur:{configurable:!0},gradientBlur:{configurable:!0},start:{configurable:!0},end:{configurable:!0}};return((e.prototype=Object.create(o&&o.prototype)).constructor=e).prototype.updateDelta=function(){this.uniforms.delta.x=0,this.uniforms.delta.y=0},t.blur.get=function(){return this.uniforms.blur},t.blur.set=function(e){this.uniforms.blur=e},t.gradientBlur.get=function(){return this.uniforms.gradientBlur},t.gradientBlur.set=function(e){this.uniforms.gradientBlur=e},t.start.get=function(){return this.uniforms.start},t.start.set=function(e){this.uniforms.start=e,this.updateDelta()},t.end.get=function(){return this.uniforms.end},t.end.set=function(e){this.uniforms.end=e,this.updateDelta()},Object.defineProperties(e.prototype,t),e}(d.Filter),W=((k=N)&&(Z.__proto__=k),((Z.prototype=Object.create(k&&k.prototype)).constructor=Z).prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,n=Math.sqrt(e*e+t*t);this.uniforms.delta.x=e/n,this.uniforms.delta.y=t/n},Z),G=((L=N)&&(U.__proto__=L),((U.prototype=Object.create(L&&L.prototype)).constructor=U).prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,n=Math.sqrt(e*e+t*t);this.uniforms.delta.x=-t/n,this.uniforms.delta.y=e/n},U),K=function(o){function e(e,t,n,r){void 0===e&&(e=100),void 0===t&&(t=600),void 0===n&&(n=null),void 0===r&&(r=null),o.call(this),this.tiltShiftXFilter=new W(e,t,n,r),this.tiltShiftYFilter=new G(e,t,n,r)}o&&(e.__proto__=o);var t={blur:{configurable:!0},gradientBlur:{configurable:!0},start:{configurable:!0},end:{configurable:!0}};return((e.prototype=Object.create(o&&o.prototype)).constructor=e).prototype.apply=function(e,t,n){var r=e.getRenderTarget(!0);this.tiltShiftXFilter.apply(e,t,r),this.tiltShiftYFilter.apply(e,r,n),e.returnRenderTarget(r)},t.blur.get=function(){return this.tiltShiftXFilter.blur},t.blur.set=function(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e},t.gradientBlur.get=function(){return this.tiltShiftXFilter.gradientBlur},t.gradientBlur.set=function(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e},t.start.get=function(){return this.tiltShiftXFilter.start},t.start.set=function(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e},t.end.get=function(){return this.tiltShiftXFilter.end},t.end.set=function(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e},Object.defineProperties(e.prototype,t),e}(d.Filter),Y=function(r){function e(e,t,n){void 0===e&&(e=200),void 0===t&&(t=4),void 0===n&&(n=20),r.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n"),this.radius=e,this.angle=t,this.padding=n}r&&(e.__proto__=r),(e.prototype=Object.create(r&&r.prototype)).constructor=e;var t={offset:{configurable:!0},radius:{configurable:!0},angle:{configurable:!0}};return t.offset.get=function(){return this.uniforms.offset},t.offset.set=function(e){this.uniforms.offset=e},t.radius.get=function(){return this.uniforms.radius},t.radius.set=function(e){this.uniforms.radius=e},t.angle.get=function(){return this.uniforms.angle},t.angle.set=function(e){this.uniforms.angle=e},Object.defineProperties(e.prototype,t),e}(d.Filter),Q=function(o){function e(e,t,n,r){void 0===e&&(e=.1),void 0===t&&(t=[0,0]),void 0===n&&(n=0),void 0===r&&(r=-1),o.call(this,"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = 32.0;\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n"),this.center=t,this.strength=e,this.innerRadius=n,this.radius=r}o&&(e.__proto__=o),(e.prototype=Object.create(o&&o.prototype)).constructor=e;var t={center:{configurable:!0},strength:{configurable:!0},innerRadius:{configurable:!0},radius:{configurable:!0}};return t.center.get=function(){return this.uniforms.uCenter},t.center.set=function(e){this.uniforms.uCenter=e},t.strength.get=function(){return this.uniforms.uStrength},t.strength.set=function(e){this.uniforms.uStrength=e},t.innerRadius.get=function(){return this.uniforms.uInnerRadius},t.innerRadius.set=function(e){this.uniforms.uInnerRadius=e},t.radius.get=function(){return this.uniforms.uRadius},t.radius.set=function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},Object.defineProperties(e.prototype,t),e}(d.Filter);function U(){L.apply(this,arguments)}function Z(){k.apply(this,arguments)}return e.AdjustmentFilter=o,e.AdvancedBloomFilter=i,e.AsciiFilter=a,e.BevelFilter=u,e.BloomFilter=g,e.BulgePinchFilter=v,e.ColorMapFilter=x,e.ColorReplaceFilter=y,e.ConvolutionFilter=b,e.CrossHatchFilter=_,e.CRTFilter=C,e.DotFilter=S,e.DropShadowFilter=T,e.EmbossFilter=F,e.GlitchFilter=z,e.GlowFilter=P,e.GodrayFilter=D,e.KawaseBlurFilter=h,e.MotionBlurFilter=M,e.MultiColorReplaceFilter=O,e.OldFilmFilter=j,e.OutlineFilter=R,e.PixelateFilter=I,e.RadialBlurFilter=E,e.ReflectionFilter=V,e.RGBSplitFilter=B,e.ShockwaveFilter=X,e.SimpleLightmapFilter=q,e.TiltShiftFilter=K,e.TiltShiftAxisFilter=N,e.TiltShiftXFilter=W,e.TiltShiftYFilter=G,e.TwistFilter=Y,e.ZoomBlurFilter=Q,e}({},PIXI);_extends(PIXI.filters,__filters);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9waXhpLWZpbHRlcnMuanMiXSwibmFtZXMiOlsiX19maWx0ZXJzIiwiZSIsInQiLCJuIiwibyIsIkZpbHRlciIsIl9fcHJvdG9fXyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiYXBwbHkiLCJyIiwidGhpcyIsInVuaWZvcm1zIiwiZ2FtbWEiLCJNYXRoIiwibWF4Iiwic2F0dXJhdGlvbiIsImNvbnRyYXN0IiwiYnJpZ2h0bmVzcyIsInJlZCIsImdyZWVuIiwiYmx1ZSIsImFscGhhIiwiYXBwbHlGaWx0ZXIiLCJhIiwiY2FsbCIsInVPZmZzZXQiLCJGbG9hdDMyQXJyYXkiLCJfcGl4ZWxTaXplIiwiUG9pbnQiLCJwaXhlbFNpemUiLCJfY2xhbXAiLCJfa2VybmVscyIsIkFycmF5IiwiaXNBcnJheSIsImtlcm5lbHMiLCJfYmx1ciIsInF1YWxpdHkiLCJjb25maWd1cmFibGUiLCJjbGFtcCIsImJsdXIiLCJpIiwieCIsInNpemUiLCJ3aWR0aCIsImwiLCJ5IiwiaGVpZ2h0IiwiX3F1YWxpdHkiLCJzIiwiZ2V0UmVuZGVyVGFyZ2V0IiwidSIsImMiLCJmIiwiaCIsInJldHVyblJlbmRlclRhcmdldCIsIl9nZW5lcmF0ZUtlcm5lbHMiLCJwdXNoIiwiZ2V0Iiwic2V0IiwibGVuZ3RoIiwicm91bmQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGhyZXNob2xkIiwicCIsIl9leHRlbmRzIiwiYmxvb21TY2FsZSIsInJlc29sdXRpb24iLCJzZXR0aW5ncyIsIlJFU09MVVRJT04iLCJfZXh0cmFjdEZpbHRlciIsIl9ibHVyRmlsdGVyIiwiYmxvb21UZXh0dXJlIiwiX3Jlc29sdXRpb24iLCJnIiwibGlnaHRDb2xvciIsInNoYWRvd0NvbG9yIiwicm90YXRpb24iLCJ0aGlja25lc3MiLCJsaWdodEFscGhhIiwic2hhZG93QWxwaGEiLCJfdXBkYXRlVHJhbnNmb3JtIiwidHJhbnNmb3JtWCIsIl90aGlja25lc3MiLCJjb3MiLCJfYW5nbGUiLCJ0cmFuc2Zvcm1ZIiwic2luIiwiREVHX1RPX1JBRCIsInV0aWxzIiwicmdiMmhleCIsImhleDJyZ2IiLCJiIiwiZmlsdGVycyIsIl8iLCJCbHVyWEZpbHRlciIsIkMiLCJCbHVyWUZpbHRlciIsIlMiLCJBbHBoYUZpbHRlciIsIkYiLCJibHVyWEZpbHRlciIsImJsdXJZRmlsdGVyIiwiYmxlbmRNb2RlIiwiQkxFTkRfTU9ERVMiLCJTQ1JFRU4iLCJkZWZhdWx0RmlsdGVyIiwiYmx1clgiLCJibHVyWSIsInciLCJkaW1lbnNpb25zIiwiY2VudGVyIiwicmFkaXVzIiwic3RyZW5ndGgiLCJzb3VyY2VGcmFtZSIsIk8iLCJfc2l6ZSIsIl9zbGljZVNpemUiLCJfc2xpY2VQaXhlbFNpemUiLCJfc2xpY2VJbm5lclNpemUiLCJfc2NhbGVNb2RlIiwiX25lYXJlc3QiLCJuZWFyZXN0IiwibWl4IiwiY29sb3JNYXAiLCJjb2xvclNpemUiLCJfbWl4IiwiX2NvbG9yTWFwIiwiVGV4dHVyZSIsImZyb20iLCJiYXNlVGV4dHVyZSIsInNjYWxlTW9kZSIsIm1pcG1hcCIsIlNDQUxFX01PREVTIiwiTkVBUkVTVCIsIkxJTkVBUiIsIl9nbFRleHR1cmVzIiwiX3VwZGF0ZUlEIiwiZW1pdCIsInVwZGF0ZUNvbG9yTWFwIiwiZGVzdHJveSIsIlIiLCJvcmlnaW5hbENvbG9yIiwibmV3Q29sb3IiLCJlcHNpbG9uIiwiX29yaWdpbmFsQ29sb3IiLCJfbmV3Q29sb3IiLCJrIiwidGV4ZWxTaXplIiwibWF0cml4IiwiZm9yRWFjaCIsIkIiLCJOIiwidGltZSIsInNlZWQiLCJjdXJ2YXR1cmUiLCJsaW5lV2lkdGgiLCJsaW5lQ29udHJhc3QiLCJ2ZXJ0aWNhbExpbmUiLCJub2lzZSIsIm5vaXNlU2l6ZSIsInZpZ25ldHRpbmciLCJ2aWduZXR0aW5nQWxwaGEiLCJ2aWduZXR0aW5nQmx1ciIsIksiLCJzY2FsZSIsImFuZ2xlIiwiVSIsImNvbnNvbGUiLCJ3YXJuIiwiYXJndW1lbnRzIiwiZGlzdGFuY2UiLCJjb2xvciIsInNoYWRvd09ubHkiLCJfdGludEZpbHRlciIsInRhcmdldFRyYW5zZm9ybSIsIk1hdHJpeCIsIl91cGRhdGVQYWRkaW5nIiwidHJhbnNmb3JtIiwicGFkZGluZyIsIl91cGRhdGVUYXJnZXRUcmFuc2Zvcm0iLCJ0eCIsInR5IiwiX2Rpc3RhbmNlIiwiSCIsImVlIiwic2xpY2VzIiwib2Zmc2V0IiwiZGlyZWN0aW9uIiwiZmlsbE1vZGUiLCJhdmVyYWdlIiwibWluU2l6ZSIsInNhbXBsZVNpemUiLCJfY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dHVyZSIsImZyb21DYW52YXMiLCJfc2xpY2VzIiwic2l6ZXMiLCJvZmZzZXRzIiwiYXNwZWN0IiwiX3JhbmRvbWl6ZVNpemVzIiwiX3NpemVzIiwibWluIiwicmFuZG9tIiwic3FydCIsInNodWZmbGUiLCJfcmFuZG9taXplT2Zmc2V0cyIsIl9vZmZzZXRzIiwicmVmcmVzaCIsInJlZHJhdyIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmbG9vciIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwidXBkYXRlIiwiZGlzcGxhY2VtZW50TWFwIiwic2xpY2VzV2lkdGgiLCJzbGljZXNPZmZzZXQiLCJfZGlyZWN0aW9uIiwic2luRGlyIiwiY29zRGlyIiwiVFJBTlNQQVJFTlQiLCJPUklHSU5BTCIsIkxPT1AiLCJDTEFNUCIsIk1JUlJPUiIsInJlIiwicmVwbGFjZSIsInRvRml4ZWQiLCJnbG93Q29sb3IiLCJvdXRlclN0cmVuZ3RoIiwiaW5uZXJTdHJlbmd0aCIsInNlIiwiZ2FpbiIsImxhY3VuYXJpdHkiLCJwYXJhbGxlbCIsIl9hbmdsZUxpZ2h0IiwibGlnaHQiLCJjZSIsInVWZWxvY2l0eSIsIl92ZWxvY2l0eSIsIk9ic2VydmFibGVQb2ludCIsInZlbG9jaXR5Q2hhbmdlZCIsInZlbG9jaXR5Iiwia2VybmVsU2l6ZSIsInVLZXJuZWxTaXplIiwiY29weSIsInBlIiwiX21heENvbG9ycyIsIl9yZXBsYWNlbWVudHMiLCJvcmlnaW5hbENvbG9ycyIsInRhcmdldENvbG9ycyIsInJlcGxhY2VtZW50cyIsIm1heENvbG9ycyIsImdlIiwic2VwaWEiLCJzY3JhdGNoIiwic2NyYXRjaERlbnNpdHkiLCJzY3JhdGNoV2lkdGgiLCJ5ZSIsIk1BWF9TQU1QTEVTIiwiTUlOX1NBTVBMRVMiLCJQSSIsIm91dGxpbmVDb2xvciIsIkNlIiwiemUiLCJ1UmFkaWFuIiwidUNlbnRlciIsInVSYWRpdXMiLCJUZSIsImFtcGxpdHVkZSIsIndhdmVMZW5ndGgiLCJtaXJyb3IiLCJib3VuZGFyeSIsIlBlIiwiamUiLCJ3YXZlbGVuZ3RoIiwic3BlZWQiLCJJZSIsImFtYmllbnRDb2xvciIsInVMaWdodG1hcCIsIl9jb2xvciIsIlhlIiwiZ3JhZGllbnRCbHVyIiwic3RhcnQiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImVuZCIsImRlbHRhIiwidGV4U2l6ZSIsImlubmVyV2lkdGgiLCJ1cGRhdGVEZWx0YSIsInFlIiwiTmUiLCJXZSIsInRpbHRTaGlmdFhGaWx0ZXIiLCJ0aWx0U2hpZnRZRmlsdGVyIiwiWWUiLCJaZSIsImlubmVyUmFkaXVzIiwidVN0cmVuZ3RoIiwidUlubmVyUmFkaXVzIiwiQWRqdXN0bWVudEZpbHRlciIsIkFkdmFuY2VkQmxvb21GaWx0ZXIiLCJBc2NpaUZpbHRlciIsIkJldmVsRmlsdGVyIiwiQmxvb21GaWx0ZXIiLCJCdWxnZVBpbmNoRmlsdGVyIiwiQ29sb3JNYXBGaWx0ZXIiLCJDb2xvclJlcGxhY2VGaWx0ZXIiLCJDb252b2x1dGlvbkZpbHRlciIsIkNyb3NzSGF0Y2hGaWx0ZXIiLCJDUlRGaWx0ZXIiLCJEb3RGaWx0ZXIiLCJEcm9wU2hhZG93RmlsdGVyIiwiRW1ib3NzRmlsdGVyIiwiR2xpdGNoRmlsdGVyIiwiR2xvd0ZpbHRlciIsIkdvZHJheUZpbHRlciIsIkthd2FzZUJsdXJGaWx0ZXIiLCJNb3Rpb25CbHVyRmlsdGVyIiwiTXVsdGlDb2xvclJlcGxhY2VGaWx0ZXIiLCJPbGRGaWxtRmlsdGVyIiwiT3V0bGluZUZpbHRlciIsIlBpeGVsYXRlRmlsdGVyIiwiUmFkaWFsQmx1ckZpbHRlciIsIlJlZmxlY3Rpb25GaWx0ZXIiLCJSR0JTcGxpdEZpbHRlciIsIlNob2Nrd2F2ZUZpbHRlciIsIlNpbXBsZUxpZ2h0bWFwRmlsdGVyIiwiVGlsdFNoaWZ0RmlsdGVyIiwiVGlsdFNoaWZ0QXhpc0ZpbHRlciIsIlRpbHRTaGlmdFhGaWx0ZXIiLCJUaWx0U2hpZnRZRmlsdGVyIiwiVHdpc3RGaWx0ZXIiLCJab29tQmx1ckZpbHRlciIsIlBJWEkiXSwibWFwcGluZ3MiOiI0TEFPSUEsVUFBVSxTQUFTQyxFQUFFQyxHQUFnQixJQUEwNXVCRCxFQUFyN3NCQSxFQUFqK0JFLEVBQUUsc1JBQW85QkMsSUFBV0gsRUFBK2pCQyxFQUFFRyxVQUFsYkgsRUFBRUksVUFBVUwsS0FBR0MsRUFBRUssVUFBVUMsT0FBT0MsT0FBT1IsR0FBR0EsRUFBRU0sWUFBdUJHLFlBQVlSLEdBQUlLLFVBQVVJLE1BQU0sU0FBU1YsRUFBRUMsRUFBRUMsRUFBRVMsR0FBR0MsS0FBS0MsU0FBU0MsTUFBTUMsS0FBS0MsSUFBSUosS0FBS0UsTUFBTSxNQUFNRixLQUFLQyxTQUFTSSxXQUFXTCxLQUFLSyxXQUFXTCxLQUFLQyxTQUFTSyxTQUFTTixLQUFLTSxTQUFTTixLQUFLQyxTQUFTTSxXQUFXUCxLQUFLTyxXQUFXUCxLQUFLQyxTQUFTTyxJQUFJUixLQUFLUSxJQUFJUixLQUFLQyxTQUFTUSxNQUFNVCxLQUFLUyxNQUFNVCxLQUFLQyxTQUFTUyxLQUFLVixLQUFLVSxLQUFLVixLQUFLQyxTQUFTVSxNQUFNWCxLQUFLVyxNQUFNdkIsRUFBRXdCLFlBQVlaLEtBQUtYLEVBQUVDLEVBQUVTLElBQUlWLEdBQW9wRHdCLEVBQUUsU0FBU3pCLEdBQUcsU0FBU0UsRUFBRUEsRUFBRVMsRUFBRVIsUUFBRyxJQUFTRCxJQUFJQSxFQUFFLFFBQUcsSUFBU1MsSUFBSUEsRUFBRSxRQUFHLElBQVNSLElBQUlBLEdBQUUsR0FBSUgsRUFBRTBCLEtBQUtkLEtBQW51RFYsc1JB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RUFBRzdTLEVBQUVtVixlQUFlckMsRUFBRzlTLEVBQS9xa0YsQ0FBa3JrRixHQUFHb1YsTUFBTWxSLFNBQWNrUixLQUFLdFAsUUFBNEIvRiIsImZpbGUiOiJsaWIvcGl4aS1maWx0ZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwaXhpLWZpbHRlcnMgLSB2Mi43LjBcbiAqIENvbXBpbGVkIFN1biwgMTMgSmFuIDIwMTkgMjI6NTE6NTIgVVRDXG4gKlxuICogcGl4aS1maWx0ZXJzIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xudmFyIF9fZmlsdGVycz1mdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO3ZhciBuPVwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxufVwiLHI9XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG51bmlmb3JtIGZsb2F0IGdhbW1hO1xcbnVuaWZvcm0gZmxvYXQgY29udHJhc3Q7XFxudW5pZm9ybSBmbG9hdCBzYXR1cmF0aW9uO1xcbnVuaWZvcm0gZmxvYXQgYnJpZ2h0bmVzcztcXG51bmlmb3JtIGZsb2F0IHJlZDtcXG51bmlmb3JtIGZsb2F0IGdyZWVuO1xcbnVuaWZvcm0gZmxvYXQgYmx1ZTtcXG51bmlmb3JtIGZsb2F0IGFscGhhO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcbiAgICAgICAgYy5yZ2IgLz0gYy5hO1xcblxcbiAgICAgICAgdmVjMyByZ2IgPSBwb3coYy5yZ2IsIHZlYzMoMS4gLyBnYW1tYSkpO1xcbiAgICAgICAgcmdiID0gbWl4KHZlYzMoLjUpLCBtaXgodmVjMyhkb3QodmVjMyguMjEyNSwgLjcxNTQsIC4wNzIxKSwgcmdiKSksIHJnYiwgc2F0dXJhdGlvbiksIGNvbnRyYXN0KTtcXG4gICAgICAgIHJnYi5yICo9IHJlZDtcXG4gICAgICAgIHJnYi5nICo9IGdyZWVuO1xcbiAgICAgICAgcmdiLmIgKj0gYmx1ZTtcXG4gICAgICAgIGMucmdiID0gcmdiICogYnJpZ2h0bmVzcztcXG5cXG4gICAgICAgIGMucmdiICo9IGMuYTtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjICogYWxwaGE7XFxufVxcblwiLG89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtlLmNhbGwodGhpcyxuLHIpLE9iamVjdC5hc3NpZ24odGhpcyx7Z2FtbWE6MSxzYXR1cmF0aW9uOjEsY29udHJhc3Q6MSxicmlnaHRuZXNzOjEscmVkOjEsZ3JlZW46MSxibHVlOjEsYWxwaGE6MX0sdCl9cmV0dXJuIGUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3RoaXMudW5pZm9ybXMuZ2FtbWE9TWF0aC5tYXgodGhpcy5nYW1tYSwxZS00KSx0aGlzLnVuaWZvcm1zLnNhdHVyYXRpb249dGhpcy5zYXR1cmF0aW9uLHRoaXMudW5pZm9ybXMuY29udHJhc3Q9dGhpcy5jb250cmFzdCx0aGlzLnVuaWZvcm1zLmJyaWdodG5lc3M9dGhpcy5icmlnaHRuZXNzLHRoaXMudW5pZm9ybXMucmVkPXRoaXMucmVkLHRoaXMudW5pZm9ybXMuZ3JlZW49dGhpcy5ncmVlbix0aGlzLnVuaWZvcm1zLmJsdWU9dGhpcy5ibHVlLHRoaXMudW5pZm9ybXMuYWxwaGE9dGhpcy5hbHBoYSxlLmFwcGx5RmlsdGVyKHRoaXMsdCxuLHIpfSx0fSh0LkZpbHRlciksaT1uLGw9XCJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG51bmlmb3JtIHZlYzIgdU9mZnNldDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxuICAgIC8vIFNhbXBsZSB0b3AgbGVmdCBwaXhlbFxcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gdU9mZnNldC54LCB2VGV4dHVyZUNvb3JkLnkgKyB1T2Zmc2V0LnkpKTtcXG5cXG4gICAgLy8gU2FtcGxlIHRvcCByaWdodCBwaXhlbFxcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdU9mZnNldC54LCB2VGV4dHVyZUNvb3JkLnkgKyB1T2Zmc2V0LnkpKTtcXG5cXG4gICAgLy8gU2FtcGxlIGJvdHRvbSByaWdodCBwaXhlbFxcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54ICsgdU9mZnNldC54LCB2VGV4dHVyZUNvb3JkLnkgLSB1T2Zmc2V0LnkpKTtcXG5cXG4gICAgLy8gU2FtcGxlIGJvdHRvbSBsZWZ0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggLSB1T2Zmc2V0LngsIHZUZXh0dXJlQ29vcmQueSAtIHVPZmZzZXQueSkpO1xcblxcbiAgICAvLyBBdmVyYWdlXFxuICAgIGNvbG9yICo9IDAuMjU7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIixzPVwiXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudW5pZm9ybSB2ZWMyIHVPZmZzZXQ7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckNsYW1wO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXG4gICAgLy8gU2FtcGxlIHRvcCBsZWZ0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggLSB1T2Zmc2V0LngsIHZUZXh0dXJlQ29vcmQueSArIHVPZmZzZXQueSksIGZpbHRlckNsYW1wLnh5LCBmaWx0ZXJDbGFtcC56dykpO1xcblxcbiAgICAvLyBTYW1wbGUgdG9wIHJpZ2h0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggKyB1T2Zmc2V0LngsIHZUZXh0dXJlQ29vcmQueSArIHVPZmZzZXQueSksIGZpbHRlckNsYW1wLnh5LCBmaWx0ZXJDbGFtcC56dykpO1xcblxcbiAgICAvLyBTYW1wbGUgYm90dG9tIHJpZ2h0IHBpeGVsXFxuICAgIGNvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggKyB1T2Zmc2V0LngsIHZUZXh0dXJlQ29vcmQueSAtIHVPZmZzZXQueSksIGZpbHRlckNsYW1wLnh5LCBmaWx0ZXJDbGFtcC56dykpO1xcblxcbiAgICAvLyBTYW1wbGUgYm90dG9tIGxlZnQgcGl4ZWxcXG4gICAgY29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjbGFtcCh2ZWMyKHZUZXh0dXJlQ29vcmQueCAtIHVPZmZzZXQueCwgdlRleHR1cmVDb29yZC55IC0gdU9mZnNldC55KSwgZmlsdGVyQ2xhbXAueHksIGZpbHRlckNsYW1wLnp3KSk7XFxuXFxuICAgIC8vIEF2ZXJhZ2VcXG4gICAgY29sb3IgKj0gMC4yNTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiLGE9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihuLHIsbyl7dm9pZCAwPT09biYmKG49NCksdm9pZCAwPT09ciYmKHI9Myksdm9pZCAwPT09byYmKG89ITEpLGUuY2FsbCh0aGlzLGksbz9zOmwpLHRoaXMudW5pZm9ybXMudU9mZnNldD1uZXcgRmxvYXQzMkFycmF5KDIpLHRoaXMuX3BpeGVsU2l6ZT1uZXcgdC5Qb2ludCx0aGlzLnBpeGVsU2l6ZT0xLHRoaXMuX2NsYW1wPW8sdGhpcy5fa2VybmVscz1udWxsLEFycmF5LmlzQXJyYXkobik/dGhpcy5rZXJuZWxzPW46KHRoaXMuX2JsdXI9bix0aGlzLnF1YWxpdHk9cil9ZSYmKG4uX19wcm90b19fPWUpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW47dmFyIHI9e2tlcm5lbHM6e2NvbmZpZ3VyYWJsZTohMH0sY2xhbXA6e2NvbmZpZ3VyYWJsZTohMH0scGl4ZWxTaXplOntjb25maWd1cmFibGU6ITB9LHF1YWxpdHk6e2NvbmZpZ3VyYWJsZTohMH0sYmx1cjp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBvLGk9dGhpcy5waXhlbFNpemUueC90LnNpemUud2lkdGgsbD10aGlzLnBpeGVsU2l6ZS55L3Quc2l6ZS5oZWlnaHQ7aWYoMT09PXRoaXMuX3F1YWxpdHl8fDA9PT10aGlzLl9ibHVyKW89dGhpcy5fa2VybmVsc1swXSsuNSx0aGlzLnVuaWZvcm1zLnVPZmZzZXRbMF09byppLHRoaXMudW5pZm9ybXMudU9mZnNldFsxXT1vKmwsZS5hcHBseUZpbHRlcih0aGlzLHQsbixyKTtlbHNle2Zvcih2YXIgcyxhPWUuZ2V0UmVuZGVyVGFyZ2V0KCEwKSx1PXQsYz1hLGY9dGhpcy5fcXVhbGl0eS0xLGg9MDtoPGY7aCsrKW89dGhpcy5fa2VybmVsc1toXSsuNSx0aGlzLnVuaWZvcm1zLnVPZmZzZXRbMF09byppLHRoaXMudW5pZm9ybXMudU9mZnNldFsxXT1vKmwsZS5hcHBseUZpbHRlcih0aGlzLHUsYywhMCkscz11LHU9YyxjPXM7bz10aGlzLl9rZXJuZWxzW2ZdKy41LHRoaXMudW5pZm9ybXMudU9mZnNldFswXT1vKmksdGhpcy51bmlmb3Jtcy51T2Zmc2V0WzFdPW8qbCxlLmFwcGx5RmlsdGVyKHRoaXMsdSxuLHIpLGUucmV0dXJuUmVuZGVyVGFyZ2V0KGEpfX0sbi5wcm90b3R5cGUuX2dlbmVyYXRlS2VybmVscz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX2JsdXIsdD10aGlzLl9xdWFsaXR5LG49W2VdO2lmKGU+MClmb3IodmFyIHI9ZSxvPWUvdCxpPTE7aTx0O2krKylyLT1vLG4ucHVzaChyKTt0aGlzLl9rZXJuZWxzPW59LHIua2VybmVscy5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fa2VybmVsc30sci5rZXJuZWxzLnNldD1mdW5jdGlvbihlKXtBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD4wPyh0aGlzLl9rZXJuZWxzPWUsdGhpcy5fcXVhbGl0eT1lLmxlbmd0aCx0aGlzLl9ibHVyPU1hdGgubWF4LmFwcGx5KE1hdGgsZSkpOih0aGlzLl9rZXJuZWxzPVswXSx0aGlzLl9xdWFsaXR5PTEpfSxyLmNsYW1wLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9jbGFtcH0sci5waXhlbFNpemUuc2V0PWZ1bmN0aW9uKGUpe1wibnVtYmVyXCI9PXR5cGVvZiBlPyh0aGlzLl9waXhlbFNpemUueD1lLHRoaXMuX3BpeGVsU2l6ZS55PWUpOkFycmF5LmlzQXJyYXkoZSk/KHRoaXMuX3BpeGVsU2l6ZS54PWVbMF0sdGhpcy5fcGl4ZWxTaXplLnk9ZVsxXSk6ZSBpbnN0YW5jZW9mIHQuUG9pbnQ/KHRoaXMuX3BpeGVsU2l6ZS54PWUueCx0aGlzLl9waXhlbFNpemUueT1lLnkpOih0aGlzLl9waXhlbFNpemUueD0xLHRoaXMuX3BpeGVsU2l6ZS55PTEpfSxyLnBpeGVsU2l6ZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGl4ZWxTaXplfSxyLnF1YWxpdHkuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3F1YWxpdHl9LHIucXVhbGl0eS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fcXVhbGl0eT1NYXRoLm1heCgxLE1hdGgucm91bmQoZSkpLHRoaXMuX2dlbmVyYXRlS2VybmVscygpfSxyLmJsdXIuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JsdXJ9LHIuYmx1ci5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fYmx1cj1lLHRoaXMuX2dlbmVyYXRlS2VybmVscygpfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksdT1uLGM9XCJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIGZsb2F0IHRocmVzaG9sZDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcblxcbiAgICAvLyBBIHNpbXBsZSAmIGZhc3QgYWxnb3JpdGhtIGZvciBnZXR0aW5nIGJyaWdodG5lc3MuXFxuICAgIC8vIEl0J3MgaW5hY2N1cmFjeSAsIGJ1dCBnb29kIGVub3VnaHQgZm9yIHRoaXMgZmVhdHVyZS5cXG4gICAgZmxvYXQgX21heCA9IG1heChtYXgoY29sb3IuciwgY29sb3IuZyksIGNvbG9yLmIpO1xcbiAgICBmbG9hdCBfbWluID0gbWluKG1pbihjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7XFxuICAgIGZsb2F0IGJyaWdodG5lc3MgPSAoX21heCArIF9taW4pICogMC41O1xcblxcbiAgICBpZihicmlnaHRuZXNzID4gdGhyZXNob2xkKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgfVxcbn1cXG5cIixmPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9LjUpLGUuY2FsbCh0aGlzLHUsYyksdGhpcy50aHJlc2hvbGQ9dH1lJiYodC5fX3Byb3RvX189ZSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dDt2YXIgbj17dGhyZXNob2xkOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi50aHJlc2hvbGQuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudGhyZXNob2xkfSxuLnRocmVzaG9sZC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy50aHJlc2hvbGQ9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLGg9XCJ1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBibG9vbVRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCBibG9vbVNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgYnJpZ2h0bmVzcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBjb2xvci5yZ2IgKj0gYnJpZ2h0bmVzcztcXG4gICAgdmVjNCBibG9vbUNvbG9yID0gdmVjNCh0ZXh0dXJlMkQoYmxvb21UZXh0dXJlLCB2VGV4dHVyZUNvb3JkKS5yZ2IsIDAuMCk7XFxuICAgIGJsb29tQ29sb3IucmdiICo9IGJsb29tU2NhbGU7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICsgYmxvb21Db2xvcjtcXG59XFxuXCIscD1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKG4pe2UuY2FsbCh0aGlzLHUsaCksXCJudW1iZXJcIj09dHlwZW9mIG4mJihuPXt0aHJlc2hvbGQ6bn0pLG49T2JqZWN0LmFzc2lnbih7dGhyZXNob2xkOi41LGJsb29tU2NhbGU6MSxicmlnaHRuZXNzOjEsa2VybmVsczpudWxsLGJsdXI6OCxxdWFsaXR5OjQscGl4ZWxTaXplOjEscmVzb2x1dGlvbjp0LnNldHRpbmdzLlJFU09MVVRJT059LG4pLHRoaXMuYmxvb21TY2FsZT1uLmJsb29tU2NhbGUsdGhpcy5icmlnaHRuZXNzPW4uYnJpZ2h0bmVzczt2YXIgcj1uLmtlcm5lbHMsbz1uLmJsdXIsaT1uLnF1YWxpdHksbD1uLnBpeGVsU2l6ZSxzPW4ucmVzb2x1dGlvbjt0aGlzLl9leHRyYWN0RmlsdGVyPW5ldyBmKG4udGhyZXNob2xkKSx0aGlzLl9leHRyYWN0RmlsdGVyLnJlc29sdXRpb249cyx0aGlzLl9ibHVyRmlsdGVyPXI/bmV3IGEocik6bmV3IGEobyxpKSx0aGlzLnBpeGVsU2l6ZT1sLHRoaXMucmVzb2x1dGlvbj1zfWUmJihuLl9fcHJvdG9fXz1lKSxuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSxuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1uO3ZhciByPXtyZXNvbHV0aW9uOntjb25maWd1cmFibGU6ITB9LHRocmVzaG9sZDp7Y29uZmlndXJhYmxlOiEwfSxrZXJuZWxzOntjb25maWd1cmFibGU6ITB9LGJsdXI6e2NvbmZpZ3VyYWJsZTohMH0scXVhbGl0eTp7Y29uZmlndXJhYmxlOiEwfSxwaXhlbFNpemU6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiBuLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQsbixyLG8pe3ZhciBpPWUuZ2V0UmVuZGVyVGFyZ2V0KCEwKTt0aGlzLl9leHRyYWN0RmlsdGVyLmFwcGx5KGUsdCxpLCEwLG8pO3ZhciBsPWUuZ2V0UmVuZGVyVGFyZ2V0KCEwKTt0aGlzLl9ibHVyRmlsdGVyLmFwcGx5KGUsaSxsLCEwLG8pLHRoaXMudW5pZm9ybXMuYmxvb21TY2FsZT10aGlzLmJsb29tU2NhbGUsdGhpcy51bmlmb3Jtcy5icmlnaHRuZXNzPXRoaXMuYnJpZ2h0bmVzcyx0aGlzLnVuaWZvcm1zLmJsb29tVGV4dHVyZT1sLGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4sciksZS5yZXR1cm5SZW5kZXJUYXJnZXQobCksZS5yZXR1cm5SZW5kZXJUYXJnZXQoaSl9LHIucmVzb2x1dGlvbi5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVzb2x1dGlvbn0sci5yZXNvbHV0aW9uLnNldD1mdW5jdGlvbihlKXt0aGlzLl9yZXNvbHV0aW9uPWUsdGhpcy5fZXh0cmFjdEZpbHRlciYmKHRoaXMuX2V4dHJhY3RGaWx0ZXIucmVzb2x1dGlvbj1lKSx0aGlzLl9ibHVyRmlsdGVyJiYodGhpcy5fYmx1ckZpbHRlci5yZXNvbHV0aW9uPWUpfSxyLnRocmVzaG9sZC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXh0cmFjdEZpbHRlci50aHJlc2hvbGR9LHIudGhyZXNob2xkLnNldD1mdW5jdGlvbihlKXt0aGlzLl9leHRyYWN0RmlsdGVyLnRocmVzaG9sZD1lfSxyLmtlcm5lbHMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIua2VybmVsc30sci5rZXJuZWxzLnNldD1mdW5jdGlvbihlKXt0aGlzLl9ibHVyRmlsdGVyLmtlcm5lbHM9ZX0sci5ibHVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ibHVyRmlsdGVyLmJsdXJ9LHIuYmx1ci5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fYmx1ckZpbHRlci5ibHVyPWV9LHIucXVhbGl0eS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5xdWFsaXR5fSxyLnF1YWxpdHkuc2V0PWZ1bmN0aW9uKGUpe3RoaXMuX2JsdXJGaWx0ZXIucXVhbGl0eT1lfSxyLnBpeGVsU2l6ZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemV9LHIucGl4ZWxTaXplLnNldD1mdW5jdGlvbihlKXt0aGlzLl9ibHVyRmlsdGVyLnBpeGVsU2l6ZT1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksZD1uLG09XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG51bmlmb3JtIGZsb2F0IHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52ZWMyIG1hcENvb3JkKCB2ZWMyIGNvb3JkIClcXG57XFxuICAgIGNvb3JkICo9IGZpbHRlckFyZWEueHk7XFxuICAgIGNvb3JkICs9IGZpbHRlckFyZWEuenc7XFxuXFxuICAgIHJldHVybiBjb29yZDtcXG59XFxuXFxudmVjMiB1bm1hcENvb3JkKCB2ZWMyIGNvb3JkIClcXG57XFxuICAgIGNvb3JkIC09IGZpbHRlckFyZWEuenc7XFxuICAgIGNvb3JkIC89IGZpbHRlckFyZWEueHk7XFxuXFxuICAgIHJldHVybiBjb29yZDtcXG59XFxuXFxudmVjMiBwaXhlbGF0ZSh2ZWMyIGNvb3JkLCB2ZWMyIHNpemUpXFxue1xcbiAgICByZXR1cm4gZmxvb3IoIGNvb3JkIC8gc2l6ZSApICogc2l6ZTtcXG59XFxuXFxudmVjMiBnZXRNb2QodmVjMiBjb29yZCwgdmVjMiBzaXplKVxcbntcXG4gICAgcmV0dXJuIG1vZCggY29vcmQgLCBzaXplKSAvIHNpemU7XFxufVxcblxcbmZsb2F0IGNoYXJhY3RlcihmbG9hdCBuLCB2ZWMyIHApXFxue1xcbiAgICBwID0gZmxvb3IocCp2ZWMyKDQuMCwgLTQuMCkgKyAyLjUpO1xcbiAgICBpZiAoY2xhbXAocC54LCAwLjAsIDQuMCkgPT0gcC54ICYmIGNsYW1wKHAueSwgMC4wLCA0LjApID09IHAueSlcXG4gICAge1xcbiAgICAgICAgaWYgKGludChtb2Qobi9leHAyKHAueCArIDUuMCpwLnkpLCAyLjApKSA9PSAxKSByZXR1cm4gMS4wO1xcbiAgICB9XFxuICAgIHJldHVybiAwLjA7XFxufVxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gbWFwQ29vcmQodlRleHR1cmVDb29yZCk7XFxuXFxuICAgIC8vIGdldCB0aGUgcm91bmRlZCBjb2xvci4uXFxuICAgIHZlYzIgcGl4Q29vcmQgPSBwaXhlbGF0ZShjb29yZCwgdmVjMihwaXhlbFNpemUpKTtcXG4gICAgcGl4Q29vcmQgPSB1bm1hcENvb3JkKHBpeENvb3JkKTtcXG5cXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgcGl4Q29vcmQpO1xcblxcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGNoYXJhY3RlciB0byB1c2VcXG4gICAgZmxvYXQgZ3JheSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcblxcbiAgICBmbG9hdCBuID0gIDY1NTM2LjA7ICAgICAgICAgICAgIC8vIC5cXG4gICAgaWYgKGdyYXkgPiAwLjIpIG4gPSA2NTYwMC4wOyAgICAvLyA6XFxuICAgIGlmIChncmF5ID4gMC4zKSBuID0gMzMyNzcyLjA7ICAgLy8gKlxcbiAgICBpZiAoZ3JheSA+IDAuNCkgbiA9IDE1MjU1MDg2LjA7IC8vIG9cXG4gICAgaWYgKGdyYXkgPiAwLjUpIG4gPSAyMzM4NTE2NC4wOyAvLyAmXFxuICAgIGlmIChncmF5ID4gMC42KSBuID0gMTUyNTIwMTQuMDsgLy8gOFxcbiAgICBpZiAoZ3JheSA+IDAuNykgbiA9IDEzMTk5NDUyLjA7IC8vIEBcXG4gICAgaWYgKGdyYXkgPiAwLjgpIG4gPSAxMTUxMjgxMC4wOyAvLyAjXFxuXFxuICAgIC8vIGdldCB0aGUgbW9kLi5cXG4gICAgdmVjMiBtb2RkID0gZ2V0TW9kKGNvb3JkLCB2ZWMyKHBpeGVsU2l6ZSkpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIGNoYXJhY3RlciggbiwgdmVjMigtMS4wKSArIG1vZGQgKiAyLjApO1xcblxcbn1cIixnPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9OCksZS5jYWxsKHRoaXMsZCxtKSx0aGlzLnNpemU9dH1lJiYodC5fX3Byb3RvX189ZSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dDt2YXIgbj17c2l6ZTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4uc2l6ZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5waXhlbFNpemV9LG4uc2l6ZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5waXhlbFNpemU9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLHY9bix4PVwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxuXFxudW5pZm9ybSBmbG9hdCB0cmFuc2Zvcm1YO1xcbnVuaWZvcm0gZmxvYXQgdHJhbnNmb3JtWTtcXG51bmlmb3JtIHZlYzMgbGlnaHRDb2xvcjtcXG51bmlmb3JtIGZsb2F0IGxpZ2h0QWxwaGE7XFxudW5pZm9ybSB2ZWMzIHNoYWRvd0NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgc2hhZG93QWxwaGE7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiB0cmFuc2Zvcm0gPSB2ZWMyKDEuMCAvIGZpbHRlckFyZWEpICogdmVjMih0cmFuc2Zvcm1YLCB0cmFuc2Zvcm1ZKTtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGZsb2F0IGxpZ2h0ID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkIC0gdHJhbnNmb3JtKS5hO1xcbiAgICBmbG9hdCBzaGFkb3cgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyB0cmFuc2Zvcm0pLmE7XFxuXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIGxpZ2h0Q29sb3IsIGNsYW1wKChjb2xvci5hIC0gbGlnaHQpICogbGlnaHRBbHBoYSwgMC4wLCAxLjApKTtcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgc2hhZG93Q29sb3IsIGNsYW1wKChjb2xvci5hIC0gc2hhZG93KSAqIHNoYWRvd0FscGhhLCAwLjAsIDEuMCkpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiAqIGNvbG9yLmEsIGNvbG9yLmEpO1xcbn1cXG5cIix5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCl7dm9pZCAwPT09dCYmKHQ9e30pLGUuY2FsbCh0aGlzLHYseCksdGhpcy51bmlmb3Jtcy5saWdodENvbG9yPW5ldyBGbG9hdDMyQXJyYXkoMyksdGhpcy51bmlmb3Jtcy5zaGFkb3dDb2xvcj1uZXcgRmxvYXQzMkFycmF5KDMpLHQ9T2JqZWN0LmFzc2lnbih7cm90YXRpb246NDUsdGhpY2tuZXNzOjIsbGlnaHRDb2xvcjoxNjc3NzIxNSxsaWdodEFscGhhOi43LHNoYWRvd0NvbG9yOjAsc2hhZG93QWxwaGE6Ljd9LHQpLHRoaXMucm90YXRpb249dC5yb3RhdGlvbix0aGlzLnRoaWNrbmVzcz10LnRoaWNrbmVzcyx0aGlzLmxpZ2h0Q29sb3I9dC5saWdodENvbG9yLHRoaXMubGlnaHRBbHBoYT10LmxpZ2h0QWxwaGEsdGhpcy5zaGFkb3dDb2xvcj10LnNoYWRvd0NvbG9yLHRoaXMuc2hhZG93QWxwaGE9dC5zaGFkb3dBbHBoYX1lJiYobi5fX3Byb3RvX189ZSksbi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bjt2YXIgcj17cm90YXRpb246e2NvbmZpZ3VyYWJsZTohMH0sdGhpY2tuZXNzOntjb25maWd1cmFibGU6ITB9LGxpZ2h0Q29sb3I6e2NvbmZpZ3VyYWJsZTohMH0sbGlnaHRBbHBoYTp7Y29uZmlndXJhYmxlOiEwfSxzaGFkb3dDb2xvcjp7Y29uZmlndXJhYmxlOiEwfSxzaGFkb3dBbHBoYTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLl91cGRhdGVUcmFuc2Zvcm09ZnVuY3Rpb24oKXt0aGlzLnVuaWZvcm1zLnRyYW5zZm9ybVg9dGhpcy5fdGhpY2tuZXNzKk1hdGguY29zKHRoaXMuX2FuZ2xlKSx0aGlzLnVuaWZvcm1zLnRyYW5zZm9ybVk9dGhpcy5fdGhpY2tuZXNzKk1hdGguc2luKHRoaXMuX2FuZ2xlKX0sci5yb3RhdGlvbi5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYW5nbGUvdC5ERUdfVE9fUkFEfSxyLnJvdGF0aW9uLnNldD1mdW5jdGlvbihlKXt0aGlzLl9hbmdsZT1lKnQuREVHX1RPX1JBRCx0aGlzLl91cGRhdGVUcmFuc2Zvcm0oKX0sci50aGlja25lc3MuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RoaWNrbmVzc30sci50aGlja25lc3Muc2V0PWZ1bmN0aW9uKGUpe3RoaXMuX3RoaWNrbmVzcz1lLHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSgpfSxyLmxpZ2h0Q29sb3IuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHQudXRpbHMucmdiMmhleCh0aGlzLnVuaWZvcm1zLmxpZ2h0Q29sb3IpfSxyLmxpZ2h0Q29sb3Iuc2V0PWZ1bmN0aW9uKGUpe3QudXRpbHMuaGV4MnJnYihlLHRoaXMudW5pZm9ybXMubGlnaHRDb2xvcil9LHIubGlnaHRBbHBoYS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5saWdodEFscGhhfSxyLmxpZ2h0QWxwaGEuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMubGlnaHRBbHBoYT1lfSxyLnNoYWRvd0NvbG9yLmdldD1mdW5jdGlvbigpe3JldHVybiB0LnV0aWxzLnJnYjJoZXgodGhpcy51bmlmb3Jtcy5zaGFkb3dDb2xvcil9LHIuc2hhZG93Q29sb3Iuc2V0PWZ1bmN0aW9uKGUpe3QudXRpbHMuaGV4MnJnYihlLHRoaXMudW5pZm9ybXMuc2hhZG93Q29sb3IpfSxyLnNoYWRvd0FscGhhLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnNoYWRvd0FscGhhfSxyLnNoYWRvd0FscGhhLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnNoYWRvd0FscGhhPWV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG4ucHJvdG90eXBlLHIpLG59KHQuRmlsdGVyKSxiPXQuZmlsdGVycyxfPWIuQmx1clhGaWx0ZXIsQz1iLkJsdXJZRmlsdGVyLFM9Yi5BbHBoYUZpbHRlcixGPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4obixyLG8saSl7dmFyIGwsczt2b2lkIDA9PT1uJiYobj0yKSx2b2lkIDA9PT1yJiYocj00KSx2b2lkIDA9PT1vJiYobz10LnNldHRpbmdzLlJFU09MVVRJT04pLHZvaWQgMD09PWkmJihpPTUpLGUuY2FsbCh0aGlzKSxcIm51bWJlclwiPT10eXBlb2Ygbj8obD1uLHM9bik6biBpbnN0YW5jZW9mIHQuUG9pbnQ/KGw9bi54LHM9bi55KTpBcnJheS5pc0FycmF5KG4pJiYobD1uWzBdLHM9blsxXSksdGhpcy5ibHVyWEZpbHRlcj1uZXcgXyhsLHIsbyxpKSx0aGlzLmJsdXJZRmlsdGVyPW5ldyBDKHMscixvLGkpLHRoaXMuYmx1cllGaWx0ZXIuYmxlbmRNb2RlPXQuQkxFTkRfTU9ERVMuU0NSRUVOLHRoaXMuZGVmYXVsdEZpbHRlcj1uZXcgU31lJiYobi5fX3Byb3RvX189ZSksbi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bjt2YXIgcj17Ymx1cjp7Y29uZmlndXJhYmxlOiEwfSxibHVyWDp7Y29uZmlndXJhYmxlOiEwfSxibHVyWTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1lLmdldFJlbmRlclRhcmdldCghMCk7dGhpcy5kZWZhdWx0RmlsdGVyLmFwcGx5KGUsdCxuKSx0aGlzLmJsdXJYRmlsdGVyLmFwcGx5KGUsdCxyKSx0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGUscixuKSxlLnJldHVyblJlbmRlclRhcmdldChyKX0sci5ibHVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXJ9LHIuYmx1ci5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5ibHVyWEZpbHRlci5ibHVyPXRoaXMuYmx1cllGaWx0ZXIuYmx1cj1lfSxyLmJsdXJYLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXJ9LHIuYmx1clguc2V0PWZ1bmN0aW9uKGUpe3RoaXMuYmx1clhGaWx0ZXIuYmx1cj1lfSxyLmJsdXJZLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXJ9LHIuYmx1clkuc2V0PWZ1bmN0aW9uKGUpe3RoaXMuYmx1cllGaWx0ZXIuYmx1cj1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksej1uLEE9XCJ1bmlmb3JtIGZsb2F0IHJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcbnVuaWZvcm0gdmVjMiBjZW50ZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckNsYW1wO1xcbnVuaWZvcm0gdmVjMiBkaW1lbnNpb25zO1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gdlRleHR1cmVDb29yZCAqIGZpbHRlckFyZWEueHk7XFxuICAgIGNvb3JkIC09IGNlbnRlciAqIGRpbWVuc2lvbnMueHk7XFxuICAgIGZsb2F0IGRpc3RhbmNlID0gbGVuZ3RoKGNvb3JkKTtcXG4gICAgaWYgKGRpc3RhbmNlIDwgcmFkaXVzKSB7XFxuICAgICAgICBmbG9hdCBwZXJjZW50ID0gZGlzdGFuY2UgLyByYWRpdXM7XFxuICAgICAgICBpZiAoc3RyZW5ndGggPiAwLjApIHtcXG4gICAgICAgICAgICBjb29yZCAqPSBtaXgoMS4wLCBzbW9vdGhzdGVwKDAuMCwgcmFkaXVzIC8gZGlzdGFuY2UsIHBlcmNlbnQpLCBzdHJlbmd0aCAqIDAuNzUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBjb29yZCAqPSBtaXgoMS4wLCBwb3cocGVyY2VudCwgMS4wICsgc3RyZW5ndGggKiAwLjc1KSAqIHJhZGl1cyAvIGRpc3RhbmNlLCAxLjAgLSBwZXJjZW50KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBjb29yZCArPSBjZW50ZXIgKiBkaW1lbnNpb25zLnh5O1xcbiAgICBjb29yZCAvPSBmaWx0ZXJBcmVhLnh5O1xcbiAgICB2ZWMyIGNsYW1wZWRDb29yZCA9IGNsYW1wKGNvb3JkLCBmaWx0ZXJDbGFtcC54eSwgZmlsdGVyQ2xhbXAuencpO1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjbGFtcGVkQ29vcmQpO1xcbiAgICBpZiAoY29vcmQgIT0gY2xhbXBlZENvb3JkKSB7XFxuICAgICAgICBjb2xvciAqPSBtYXgoMC4wLCAxLjAgLSBsZW5ndGgoY29vcmQgLSBjbGFtcGVkQ29vcmQpKTtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCIsdz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbixyKXtlLmNhbGwodGhpcyx6LEEpLHRoaXMudW5pZm9ybXMuZGltZW5zaW9ucz1uZXcgRmxvYXQzMkFycmF5KDIpLHRoaXMuY2VudGVyPXR8fFsuNSwuNV0sdGhpcy5yYWRpdXM9XCJudW1iZXJcIj09dHlwZW9mIG4/bjoxMDAsdGhpcy5zdHJlbmd0aD1cIm51bWJlclwiPT10eXBlb2Ygcj9yOjF9ZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQ7dmFyIG49e3JhZGl1czp7Y29uZmlndXJhYmxlOiEwfSxzdHJlbmd0aDp7Y29uZmlndXJhYmxlOiEwfSxjZW50ZXI6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiB0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQsbixyKXt0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnNbMF09dC5zb3VyY2VGcmFtZS53aWR0aCx0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnNbMV09dC5zb3VyY2VGcmFtZS5oZWlnaHQsZS5hcHBseUZpbHRlcih0aGlzLHQsbixyKX0sbi5yYWRpdXMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMucmFkaXVzfSxuLnJhZGl1cy5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5yYWRpdXM9ZX0sbi5zdHJlbmd0aC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aH0sbi5zdHJlbmd0aC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5zdHJlbmd0aD1lfSxuLmNlbnRlci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5jZW50ZXJ9LG4uY2VudGVyLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmNlbnRlcj1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksVD1uLEQ9XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBjb2xvck1hcDtcXG51bmlmb3JtIGZsb2F0IF9taXg7XFxudW5pZm9ybSBmbG9hdCBfc2l6ZTtcXG51bmlmb3JtIGZsb2F0IF9zbGljZVNpemU7XFxudW5pZm9ybSBmbG9hdCBfc2xpY2VQaXhlbFNpemU7XFxudW5pZm9ybSBmbG9hdCBfc2xpY2VJbm5lclNpemU7XFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLnh5KTtcXG5cXG4gICAgdmVjNCBhZGp1c3RlZDtcXG4gICAgaWYgKGNvbG9yLmEgPiAwLjApIHtcXG4gICAgICAgIGNvbG9yLnJnYiAvPSBjb2xvci5hO1xcbiAgICAgICAgZmxvYXQgaW5uZXJXaWR0aCA9IF9zaXplIC0gMS4wO1xcbiAgICAgICAgZmxvYXQgelNsaWNlMCA9IG1pbihmbG9vcihjb2xvci5iICogaW5uZXJXaWR0aCksIGlubmVyV2lkdGgpO1xcbiAgICAgICAgZmxvYXQgelNsaWNlMSA9IG1pbih6U2xpY2UwICsgMS4wLCBpbm5lcldpZHRoKTtcXG4gICAgICAgIGZsb2F0IHhPZmZzZXQgPSBfc2xpY2VQaXhlbFNpemUgKiAwLjUgKyBjb2xvci5yICogX3NsaWNlSW5uZXJTaXplO1xcbiAgICAgICAgZmxvYXQgczAgPSB4T2Zmc2V0ICsgKHpTbGljZTAgKiBfc2xpY2VTaXplKTtcXG4gICAgICAgIGZsb2F0IHMxID0geE9mZnNldCArICh6U2xpY2UxICogX3NsaWNlU2l6ZSk7XFxuICAgICAgICBmbG9hdCB5T2Zmc2V0ID0gX3NsaWNlU2l6ZSAqIDAuNSArIGNvbG9yLmcgKiAoMS4wIC0gX3NsaWNlU2l6ZSk7XFxuICAgICAgICB2ZWM0IHNsaWNlMENvbG9yID0gdGV4dHVyZTJEKGNvbG9yTWFwLCB2ZWMyKHMwLHlPZmZzZXQpKTtcXG4gICAgICAgIHZlYzQgc2xpY2UxQ29sb3IgPSB0ZXh0dXJlMkQoY29sb3JNYXAsIHZlYzIoczEseU9mZnNldCkpO1xcbiAgICAgICAgZmxvYXQgek9mZnNldCA9IGZyYWN0KGNvbG9yLmIgKiBpbm5lcldpZHRoKTtcXG4gICAgICAgIGFkanVzdGVkID0gbWl4KHNsaWNlMENvbG9yLCBzbGljZTFDb2xvciwgek9mZnNldCk7XFxuXFxuICAgICAgICBjb2xvci5yZ2IgKj0gY29sb3IuYTtcXG4gICAgfVxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChjb2xvciwgYWRqdXN0ZWQsIF9taXgpLnJnYiwgY29sb3IuYSk7XFxuXFxufVwiLE89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbih0LG4scil7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPTEpLGUuY2FsbCh0aGlzLFQsRCksdGhpcy5fc2l6ZT0wLHRoaXMuX3NsaWNlU2l6ZT0wLHRoaXMuX3NsaWNlUGl4ZWxTaXplPTAsdGhpcy5fc2xpY2VJbm5lclNpemU9MCx0aGlzLl9zY2FsZU1vZGU9bnVsbCx0aGlzLl9uZWFyZXN0PSExLHRoaXMubmVhcmVzdD1uLHRoaXMubWl4PXIsdGhpcy5jb2xvck1hcD10fWUmJihuLl9fcHJvdG9fXz1lKSxuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSxuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1uO3ZhciByPXtjb2xvclNpemU6e2NvbmZpZ3VyYWJsZTohMH0sY29sb3JNYXA6e2NvbmZpZ3VyYWJsZTohMH0sbmVhcmVzdDp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3RoaXMudW5pZm9ybXMuX21peD10aGlzLm1peCxlLmFwcGx5RmlsdGVyKHRoaXMsdCxuLHIpfSxyLmNvbG9yU2l6ZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZX0sci5jb2xvck1hcC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29sb3JNYXB9LHIuY29sb3JNYXAuc2V0PWZ1bmN0aW9uKGUpe2UgaW5zdGFuY2VvZiB0LlRleHR1cmV8fChlPXQuVGV4dHVyZS5mcm9tKGUpKSxlJiZlLmJhc2VUZXh0dXJlJiYoZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGU9dGhpcy5fc2NhbGVNb2RlLGUuYmFzZVRleHR1cmUubWlwbWFwPSExLHRoaXMuX3NpemU9ZS5oZWlnaHQsdGhpcy5fc2xpY2VTaXplPTEvdGhpcy5fc2l6ZSx0aGlzLl9zbGljZVBpeGVsU2l6ZT10aGlzLl9zbGljZVNpemUvdGhpcy5fc2l6ZSx0aGlzLl9zbGljZUlubmVyU2l6ZT10aGlzLl9zbGljZVBpeGVsU2l6ZSoodGhpcy5fc2l6ZS0xKSx0aGlzLnVuaWZvcm1zLl9zaXplPXRoaXMuX3NpemUsdGhpcy51bmlmb3Jtcy5fc2xpY2VTaXplPXRoaXMuX3NsaWNlU2l6ZSx0aGlzLnVuaWZvcm1zLl9zbGljZVBpeGVsU2l6ZT10aGlzLl9zbGljZVBpeGVsU2l6ZSx0aGlzLnVuaWZvcm1zLl9zbGljZUlubmVyU2l6ZT10aGlzLl9zbGljZUlubmVyU2l6ZSx0aGlzLnVuaWZvcm1zLmNvbG9yTWFwPWUpLHRoaXMuX2NvbG9yTWFwPWV9LHIubmVhcmVzdC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbmVhcmVzdH0sci5uZWFyZXN0LnNldD1mdW5jdGlvbihlKXt0aGlzLl9uZWFyZXN0PWUsdGhpcy5fc2NhbGVNb2RlPWU/dC5TQ0FMRV9NT0RFUy5ORUFSRVNUOnQuU0NBTEVfTU9ERVMuTElORUFSO3ZhciBuPXRoaXMuX2NvbG9yTWFwO24mJm4uYmFzZVRleHR1cmUmJihuLmJhc2VUZXh0dXJlLl9nbFRleHR1cmVzPXt9LG4uYmFzZVRleHR1cmUuc2NhbGVNb2RlPXRoaXMuX3NjYWxlTW9kZSxuLmJhc2VUZXh0dXJlLm1pcG1hcD0hMSxuLl91cGRhdGVJRCsrLG4uYmFzZVRleHR1cmUuZW1pdChcInVwZGF0ZVwiLG4uYmFzZVRleHR1cmUpKX0sbi5wcm90b3R5cGUudXBkYXRlQ29sb3JNYXA9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9jb2xvck1hcDtlJiZlLmJhc2VUZXh0dXJlJiYoZS5fdXBkYXRlSUQrKyxlLmJhc2VUZXh0dXJlLmVtaXQoXCJ1cGRhdGVcIixlLmJhc2VUZXh0dXJlKSx0aGlzLmNvbG9yTWFwPWUpfSxuLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKHQpe3RoaXMuX2NvbG9yTWFwJiZ0aGlzLl9jb2xvck1hcC5kZXN0cm95KHQpLGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobi5wcm90b3R5cGUsciksbn0odC5GaWx0ZXIpLFA9bixNPVwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWMzIG9yaWdpbmFsQ29sb3I7XFxudW5pZm9ybSB2ZWMzIG5ld0NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgZXBzaWxvbjtcXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWM0IGN1cnJlbnRDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIHZlYzMgY29sb3JEaWZmID0gb3JpZ2luYWxDb2xvciAtIChjdXJyZW50Q29sb3IucmdiIC8gbWF4KGN1cnJlbnRDb2xvci5hLCAwLjAwMDAwMDAwMDEpKTtcXG4gICAgZmxvYXQgY29sb3JEaXN0YW5jZSA9IGxlbmd0aChjb2xvckRpZmYpO1xcbiAgICBmbG9hdCBkb1JlcGxhY2UgPSBzdGVwKGNvbG9yRGlzdGFuY2UsIGVwc2lsb24pO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChjdXJyZW50Q29sb3IucmdiLCAobmV3Q29sb3IgKyBjb2xvckRpZmYpICogY3VycmVudENvbG9yLmEsIGRvUmVwbGFjZSksIGN1cnJlbnRDb2xvci5hKTtcXG59XFxuXCIsUj1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsbixyKXt2b2lkIDA9PT10JiYodD0xNjcxMTY4MCksdm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09ciYmKHI9LjQpLGUuY2FsbCh0aGlzLFAsTSksdGhpcy51bmlmb3Jtcy5vcmlnaW5hbENvbG9yPW5ldyBGbG9hdDMyQXJyYXkoMyksdGhpcy51bmlmb3Jtcy5uZXdDb2xvcj1uZXcgRmxvYXQzMkFycmF5KDMpLHRoaXMub3JpZ2luYWxDb2xvcj10LHRoaXMubmV3Q29sb3I9bix0aGlzLmVwc2lsb249cn1lJiYobi5fX3Byb3RvX189ZSksbi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bjt2YXIgcj17b3JpZ2luYWxDb2xvcjp7Y29uZmlndXJhYmxlOiEwfSxuZXdDb2xvcjp7Y29uZmlndXJhYmxlOiEwfSxlcHNpbG9uOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gci5vcmlnaW5hbENvbG9yLnNldD1mdW5jdGlvbihlKXt2YXIgbj10aGlzLnVuaWZvcm1zLm9yaWdpbmFsQ29sb3I7XCJudW1iZXJcIj09dHlwZW9mIGU/KHQudXRpbHMuaGV4MnJnYihlLG4pLHRoaXMuX29yaWdpbmFsQ29sb3I9ZSk6KG5bMF09ZVswXSxuWzFdPWVbMV0sblsyXT1lWzJdLHRoaXMuX29yaWdpbmFsQ29sb3I9dC51dGlscy5yZ2IyaGV4KG4pKX0sci5vcmlnaW5hbENvbG9yLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcmlnaW5hbENvbG9yfSxyLm5ld0NvbG9yLnNldD1mdW5jdGlvbihlKXt2YXIgbj10aGlzLnVuaWZvcm1zLm5ld0NvbG9yO1wibnVtYmVyXCI9PXR5cGVvZiBlPyh0LnV0aWxzLmhleDJyZ2IoZSxuKSx0aGlzLl9uZXdDb2xvcj1lKTooblswXT1lWzBdLG5bMV09ZVsxXSxuWzJdPWVbMl0sdGhpcy5fbmV3Q29sb3I9dC51dGlscy5yZ2IyaGV4KG4pKX0sci5uZXdDb2xvci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbmV3Q29sb3J9LHIuZXBzaWxvbi5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5lcHNpbG9uPWV9LHIuZXBzaWxvbi5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5lcHNpbG9ufSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksaj1uLEw9XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIG1lZGl1bXAgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxudW5pZm9ybSBmbG9hdCBtYXRyaXhbOV07XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgIHZlYzQgYzExID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkIC0gdGV4ZWxTaXplKTsgLy8gdG9wIGxlZnRcXG4gICB2ZWM0IGMxMiA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLngsIHZUZXh0dXJlQ29vcmQueSAtIHRleGVsU2l6ZS55KSk7IC8vIHRvcCBjZW50ZXJcXG4gICB2ZWM0IGMxMyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih2VGV4dHVyZUNvb3JkLnggKyB0ZXhlbFNpemUueCwgdlRleHR1cmVDb29yZC55IC0gdGV4ZWxTaXplLnkpKTsgLy8gdG9wIHJpZ2h0XFxuXFxuICAgdmVjNCBjMjEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gdGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSkpOyAvLyBtaWQgbGVmdFxcbiAgIHZlYzQgYzIyID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsgLy8gbWlkIGNlbnRlclxcbiAgIHZlYzQgYzIzID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2ZWMyKHZUZXh0dXJlQ29vcmQueCArIHRleGVsU2l6ZS54LCB2VGV4dHVyZUNvb3JkLnkpKTsgLy8gbWlkIHJpZ2h0XFxuXFxuICAgdmVjNCBjMzEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54IC0gdGV4ZWxTaXplLngsIHZUZXh0dXJlQ29vcmQueSArIHRleGVsU2l6ZS55KSk7IC8vIGJvdHRvbSBsZWZ0XFxuICAgdmVjNCBjMzIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIodlRleHR1cmVDb29yZC54LCB2VGV4dHVyZUNvb3JkLnkgKyB0ZXhlbFNpemUueSkpOyAvLyBib3R0b20gY2VudGVyXFxuICAgdmVjNCBjMzMgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyB0ZXhlbFNpemUpOyAvLyBib3R0b20gcmlnaHRcXG5cXG4gICBnbF9GcmFnQ29sb3IgPVxcbiAgICAgICBjMTEgKiBtYXRyaXhbMF0gKyBjMTIgKiBtYXRyaXhbMV0gKyBjMTMgKiBtYXRyaXhbMl0gK1xcbiAgICAgICBjMjEgKiBtYXRyaXhbM10gKyBjMjIgKiBtYXRyaXhbNF0gKyBjMjMgKiBtYXRyaXhbNV0gK1xcbiAgICAgICBjMzEgKiBtYXRyaXhbNl0gKyBjMzIgKiBtYXRyaXhbN10gKyBjMzMgKiBtYXRyaXhbOF07XFxuXFxuICAgZ2xfRnJhZ0NvbG9yLmEgPSBjMjIuYTtcXG59XFxuXCIsaz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbixyKXt2b2lkIDA9PT1uJiYobj0yMDApLHZvaWQgMD09PXImJihyPTIwMCksZS5jYWxsKHRoaXMsaixMKSx0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZT1uZXcgRmxvYXQzMkFycmF5KDIpLHRoaXMudW5pZm9ybXMubWF0cml4PW5ldyBGbG9hdDMyQXJyYXkoOSksdm9pZCAwIT09dCYmKHRoaXMubWF0cml4PXQpLHRoaXMud2lkdGg9bix0aGlzLmhlaWdodD1yfWUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10O3ZhciBuPXttYXRyaXg6e2NvbmZpZ3VyYWJsZTohMH0sd2lkdGg6e2NvbmZpZ3VyYWJsZTohMH0saGVpZ2h0Ontjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5tYXRyaXguZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMubWF0cml4fSxuLm1hdHJpeC5zZXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlLmZvckVhY2goZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC51bmlmb3Jtcy5tYXRyaXhbbl09ZX0pfSxuLndpZHRoLmdldD1mdW5jdGlvbigpe3JldHVybiAxL3RoaXMudW5pZm9ybXMudGV4ZWxTaXplWzBdfSxuLndpZHRoLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZVswXT0xL2V9LG4uaGVpZ2h0LmdldD1mdW5jdGlvbigpe3JldHVybiAxL3RoaXMudW5pZm9ybXMudGV4ZWxTaXplWzFdfSxuLmhlaWdodC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy50ZXhlbFNpemVbMV09MS9lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksST1uLEU9XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGZsb2F0IGx1bSA9IGxlbmd0aCh0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQueHkpLnJnYik7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgaWYgKGx1bSA8IDEuMDApXFxuICAgIHtcXG4gICAgICAgIGlmIChtb2QoZ2xfRnJhZ0Nvb3JkLnggKyBnbF9GcmFnQ29vcmQueSwgMTAuMCkgPT0gMC4wKVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAobHVtIDwgMC43NSlcXG4gICAge1xcbiAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55LCAxMC4wKSA9PSAwLjApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChsdW0gPCAwLjUwKVxcbiAgICB7XFxuICAgICAgICBpZiAobW9kKGdsX0ZyYWdDb29yZC54ICsgZ2xfRnJhZ0Nvb3JkLnkgLSA1LjAsIDEwLjApID09IDAuMClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGx1bSA8IDAuMylcXG4gICAge1xcbiAgICAgICAgaWYgKG1vZChnbF9GcmFnQ29vcmQueCAtIGdsX0ZyYWdDb29yZC55IC0gNS4wLCAxMC4wKSA9PSAwLjApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcblwiLEI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe2UuY2FsbCh0aGlzLEksRSl9cmV0dXJuIGUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LHR9KHQuRmlsdGVyKSxYPW4scT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnVuaWZvcm0gdmVjNCBmaWx0ZXJBcmVhO1xcbnVuaWZvcm0gdmVjMiBkaW1lbnNpb25zO1xcblxcbmNvbnN0IGZsb2F0IFNRUlRfMiA9IDEuNDE0MjEzO1xcblxcbmNvbnN0IGZsb2F0IGxpZ2h0ID0gMS4wO1xcblxcbnVuaWZvcm0gZmxvYXQgY3VydmF0dXJlO1xcbnVuaWZvcm0gZmxvYXQgbGluZVdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgbGluZUNvbnRyYXN0O1xcbnVuaWZvcm0gYm9vbCB2ZXJ0aWNhbExpbmU7XFxudW5pZm9ybSBmbG9hdCBub2lzZTtcXG51bmlmb3JtIGZsb2F0IG5vaXNlU2l6ZTtcXG5cXG51bmlmb3JtIGZsb2F0IHZpZ25ldHRpbmc7XFxudW5pZm9ybSBmbG9hdCB2aWduZXR0aW5nQWxwaGE7XFxudW5pZm9ybSBmbG9hdCB2aWduZXR0aW5nQmx1cjtcXG5cXG51bmlmb3JtIGZsb2F0IHNlZWQ7XFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcbmZsb2F0IHJhbmQodmVjMiBjbykge1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIHBpeGVsQ29vcmQgPSB2VGV4dHVyZUNvb3JkLnh5ICogZmlsdGVyQXJlYS54eTtcXG4gICAgdmVjMiBjb29yZCA9IHBpeGVsQ29vcmQgLyBkaW1lbnNpb25zO1xcblxcbiAgICB2ZWMyIGRpciA9IHZlYzIoY29vcmQgLSB2ZWMyKDAuNSwgMC41KSk7XFxuXFxuICAgIGZsb2F0IF9jID0gY3VydmF0dXJlID4gMC4gPyBjdXJ2YXR1cmUgOiAxLjtcXG4gICAgZmxvYXQgayA9IGN1cnZhdHVyZSA+IDAuID8obGVuZ3RoKGRpciAqIGRpcikgKiAwLjI1ICogX2MgKiBfYyArIDAuOTM1ICogX2MpIDogMS47XFxuICAgIHZlYzIgdXYgPSBkaXIgKiBrO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWMzIHJnYiA9IGdsX0ZyYWdDb2xvci5yZ2I7XFxuXFxuXFxuICAgIGlmIChub2lzZSA+IDAuMCAmJiBub2lzZVNpemUgPiAwLjApXFxuICAgIHtcXG4gICAgICAgIHBpeGVsQ29vcmQueCA9IGZsb29yKHBpeGVsQ29vcmQueCAvIG5vaXNlU2l6ZSk7XFxuICAgICAgICBwaXhlbENvb3JkLnkgPSBmbG9vcihwaXhlbENvb3JkLnkgLyBub2lzZVNpemUpO1xcbiAgICAgICAgZmxvYXQgX25vaXNlID0gcmFuZChwaXhlbENvb3JkICogbm9pc2VTaXplICogc2VlZCkgLSAwLjU7XFxuICAgICAgICByZ2IgKz0gX25vaXNlICogbm9pc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKGxpbmVXaWR0aCA+IDAuMCkge1xcbiAgICAgICAgZmxvYXQgdiA9ICh2ZXJ0aWNhbExpbmUgPyB1di54ICogZGltZW5zaW9ucy54IDogdXYueSAqIGRpbWVuc2lvbnMueSkgKiBtaW4oMS4wLCAyLjAgLyBsaW5lV2lkdGggKSAvIF9jO1xcbiAgICAgICAgZmxvYXQgaiA9IDEuICsgY29zKHYgKiAxLjIgLSB0aW1lKSAqIDAuNSAqIGxpbmVDb250cmFzdDtcXG4gICAgICAgIHJnYiAqPSBqO1xcbiAgICAgICAgZmxvYXQgc2VnbWVudCA9IHZlcnRpY2FsTGluZSA/IG1vZCgoZGlyLnggKyAuNSkgKiBkaW1lbnNpb25zLngsIDQuKSA6IG1vZCgoZGlyLnkgKyAuNSkgKiBkaW1lbnNpb25zLnksIDQuKTtcXG4gICAgICAgIHJnYiAqPSAwLjk5ICsgY2VpbChzZWdtZW50KSAqIDAuMDE1O1xcbiAgICB9XFxuXFxuICAgIGlmICh2aWduZXR0aW5nID4gMC4wKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBvdXR0ZXIgPSBTUVJUXzIgLSB2aWduZXR0aW5nICogU1FSVF8yO1xcbiAgICAgICAgZmxvYXQgZGFya2VyID0gY2xhbXAoKG91dHRlciAtIGxlbmd0aChkaXIpICogU1FSVF8yKSAvICggMC4wMDAwMSArIHZpZ25ldHRpbmdCbHVyICogU1FSVF8yKSwgMC4wLCAxLjApO1xcbiAgICAgICAgcmdiICo9IGRhcmtlciArICgxLjAgLSBkYXJrZXIpICogKDEuMCAtIHZpZ25ldHRpbmdBbHBoYSk7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IHJnYjtcXG59XFxuXCIsTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe2UuY2FsbCh0aGlzLFgscSksdGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zPW5ldyBGbG9hdDMyQXJyYXkoMiksdGhpcy50aW1lPTAsdGhpcy5zZWVkPTAsT2JqZWN0LmFzc2lnbih0aGlzLHtjdXJ2YXR1cmU6MSxsaW5lV2lkdGg6MSxsaW5lQ29udHJhc3Q6LjI1LHZlcnRpY2FsTGluZTohMSxub2lzZTowLG5vaXNlU2l6ZToxLHNlZWQ6MCx2aWduZXR0aW5nOi4zLHZpZ25ldHRpbmdBbHBoYToxLHZpZ25ldHRpbmdCbHVyOi4zLHRpbWU6MH0sdCl9ZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQ7dmFyIG49e2N1cnZhdHVyZTp7Y29uZmlndXJhYmxlOiEwfSxsaW5lV2lkdGg6e2NvbmZpZ3VyYWJsZTohMH0sbGluZUNvbnRyYXN0Ontjb25maWd1cmFibGU6ITB9LHZlcnRpY2FsTGluZTp7Y29uZmlndXJhYmxlOiEwfSxub2lzZTp7Y29uZmlndXJhYmxlOiEwfSxub2lzZVNpemU6e2NvbmZpZ3VyYWJsZTohMH0sdmlnbmV0dGluZzp7Y29uZmlndXJhYmxlOiEwfSx2aWduZXR0aW5nQWxwaGE6e2NvbmZpZ3VyYWJsZTohMH0sdmlnbmV0dGluZ0JsdXI6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiB0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQsbixyKXt0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnNbMF09dC5zb3VyY2VGcmFtZS53aWR0aCx0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnNbMV09dC5zb3VyY2VGcmFtZS5oZWlnaHQsdGhpcy51bmlmb3Jtcy5zZWVkPXRoaXMuc2VlZCx0aGlzLnVuaWZvcm1zLnRpbWU9dGhpcy50aW1lLGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4scil9LG4uY3VydmF0dXJlLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmN1cnZhdHVyZT1lfSxuLmN1cnZhdHVyZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5jdXJ2YXR1cmV9LG4ubGluZVdpZHRoLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmxpbmVXaWR0aD1lfSxuLmxpbmVXaWR0aC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5saW5lV2lkdGh9LG4ubGluZUNvbnRyYXN0LnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmxpbmVDb250cmFzdD1lfSxuLmxpbmVDb250cmFzdC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5saW5lQ29udHJhc3R9LG4udmVydGljYWxMaW5lLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnZlcnRpY2FsTGluZT1lfSxuLnZlcnRpY2FsTGluZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy52ZXJ0aWNhbExpbmV9LG4ubm9pc2Uuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMubm9pc2U9ZX0sbi5ub2lzZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5ub2lzZX0sbi5ub2lzZVNpemUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMubm9pc2VTaXplPWV9LG4ubm9pc2VTaXplLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLm5vaXNlU2l6ZX0sbi52aWduZXR0aW5nLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnZpZ25ldHRpbmc9ZX0sbi52aWduZXR0aW5nLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnZpZ25ldHRpbmd9LG4udmlnbmV0dGluZ0FscGhhLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnZpZ25ldHRpbmdBbHBoYT1lfSxuLnZpZ25ldHRpbmdBbHBoYS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy52aWduZXR0aW5nQWxwaGF9LG4udmlnbmV0dGluZ0JsdXIuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMudmlnbmV0dGluZ0JsdXI9ZX0sbi52aWduZXR0aW5nQmx1ci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy52aWduZXR0aW5nQmx1cn0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLFc9bixHPVwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG5cXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuXFxuZmxvYXQgcGF0dGVybigpXFxue1xcbiAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpLCBjID0gY29zKGFuZ2xlKTtcXG4gICB2ZWMyIHRleCA9IHZUZXh0dXJlQ29vcmQgKiBmaWx0ZXJBcmVhLnh5O1xcbiAgIHZlYzIgcG9pbnQgPSB2ZWMyKFxcbiAgICAgICBjICogdGV4LnggLSBzICogdGV4LnksXFxuICAgICAgIHMgKiB0ZXgueCArIGMgKiB0ZXgueVxcbiAgICkgKiBzY2FsZTtcXG4gICByZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7XFxufVxcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgIGZsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcXG4gICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoYXZlcmFnZSAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkpLCBjb2xvci5hKTtcXG59XFxuXCIsSz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbil7dm9pZCAwPT09dCYmKHQ9MSksdm9pZCAwPT09biYmKG49NSksZS5jYWxsKHRoaXMsVyxHKSx0aGlzLnNjYWxlPXQsdGhpcy5hbmdsZT1ufWUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10O3ZhciBuPXtzY2FsZTp7Y29uZmlndXJhYmxlOiEwfSxhbmdsZTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4uc2NhbGUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuc2NhbGV9LG4uc2NhbGUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuc2NhbGU9ZX0sbi5hbmdsZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5hbmdsZX0sbi5hbmdsZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5hbmdsZT1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksWT1uLFE9XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IGFscGhhO1xcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG52b2lkIG1haW4odm9pZCl7XFxuICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvclxcbiAgICBpZiAoc2FtcGxlLmEgPiAwLjApIHtcXG4gICAgICAgIHNhbXBsZS5yZ2IgLz0gc2FtcGxlLmE7XFxuICAgIH1cXG5cXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW5cXG4gICAgc2FtcGxlLnJnYiA9IGNvbG9yLnJnYiAqIHNhbXBsZS5hO1xcblxcbiAgICAvLyBhbHBoYSB1c2VyIGFscGhhXFxuICAgIHNhbXBsZSAqPSBhbHBoYTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gc2FtcGxlO1xcbn1cIixVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4obil7biYmbi5jb25zdHJ1Y3RvciE9PU9iamVjdCYmKGNvbnNvbGUud2FybihcIkRyb3BTaGFkb3dGaWx0ZXIgbm93IHVzZXMgb3B0aW9ucyBpbnN0ZWFkIG9mIChyb3RhdGlvbiwgZGlzdGFuY2UsIGJsdXIsIGNvbG9yLCBhbHBoYSlcIiksbj17cm90YXRpb246bn0sdm9pZCAwIT09YXJndW1lbnRzWzFdJiYobi5kaXN0YW5jZT1hcmd1bWVudHNbMV0pLHZvaWQgMCE9PWFyZ3VtZW50c1syXSYmKG4uYmx1cj1hcmd1bWVudHNbMl0pLHZvaWQgMCE9PWFyZ3VtZW50c1szXSYmKG4uY29sb3I9YXJndW1lbnRzWzNdKSx2b2lkIDAhPT1hcmd1bWVudHNbNF0mJihuLmFscGhhPWFyZ3VtZW50c1s0XSkpLG49T2JqZWN0LmFzc2lnbih7cm90YXRpb246NDUsZGlzdGFuY2U6NSxjb2xvcjowLGFscGhhOi41LHNoYWRvd09ubHk6ITEsa2VybmVsczpudWxsLGJsdXI6MixxdWFsaXR5OjMscGl4ZWxTaXplOjEscmVzb2x1dGlvbjp0LnNldHRpbmdzLlJFU09MVVRJT059LG4pLGUuY2FsbCh0aGlzKTt2YXIgcj1uLmtlcm5lbHMsbz1uLmJsdXIsaT1uLnF1YWxpdHksbD1uLnBpeGVsU2l6ZSxzPW4ucmVzb2x1dGlvbjt0aGlzLl90aW50RmlsdGVyPW5ldyB0LkZpbHRlcihZLFEpLHRoaXMuX3RpbnRGaWx0ZXIudW5pZm9ybXMuY29sb3I9bmV3IEZsb2F0MzJBcnJheSg0KSx0aGlzLl90aW50RmlsdGVyLnJlc29sdXRpb249cyx0aGlzLl9ibHVyRmlsdGVyPXI/bmV3IGEocik6bmV3IGEobyxpKSx0aGlzLnBpeGVsU2l6ZT1sLHRoaXMucmVzb2x1dGlvbj1zLHRoaXMudGFyZ2V0VHJhbnNmb3JtPW5ldyB0Lk1hdHJpeDt2YXIgdT1uLnNoYWRvd09ubHksYz1uLnJvdGF0aW9uLGY9bi5kaXN0YW5jZSxoPW4uYWxwaGEscD1uLmNvbG9yO3RoaXMuc2hhZG93T25seT11LHRoaXMucm90YXRpb249Yyx0aGlzLmRpc3RhbmNlPWYsdGhpcy5hbHBoYT1oLHRoaXMuY29sb3I9cCx0aGlzLl91cGRhdGVQYWRkaW5nKCl9ZSYmKG4uX19wcm90b19fPWUpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW47dmFyIHI9e3Jlc29sdXRpb246e2NvbmZpZ3VyYWJsZTohMH0sZGlzdGFuY2U6e2NvbmZpZ3VyYWJsZTohMH0scm90YXRpb246e2NvbmZpZ3VyYWJsZTohMH0sYWxwaGE6e2NvbmZpZ3VyYWJsZTohMH0sY29sb3I6e2NvbmZpZ3VyYWJsZTohMH0sa2VybmVsczp7Y29uZmlndXJhYmxlOiEwfSxibHVyOntjb25maWd1cmFibGU6ITB9LHF1YWxpdHk6e2NvbmZpZ3VyYWJsZTohMH0scGl4ZWxTaXplOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89ZS5nZXRSZW5kZXJUYXJnZXQoKTtvLnRyYW5zZm9ybT10aGlzLnRhcmdldFRyYW5zZm9ybSx0aGlzLl90aW50RmlsdGVyLmFwcGx5KGUsdCxvLCEwKSxvLnRyYW5zZm9ybT1udWxsLHRoaXMuX2JsdXJGaWx0ZXIuYXBwbHkoZSxvLG4sciksITAhPT10aGlzLnNoYWRvd09ubHkmJmUuYXBwbHlGaWx0ZXIodGhpcyx0LG4sITEpLGUucmV0dXJuUmVuZGVyVGFyZ2V0KG8pfSxuLnByb3RvdHlwZS5fdXBkYXRlUGFkZGluZz1mdW5jdGlvbigpe3RoaXMucGFkZGluZz10aGlzLmRpc3RhbmNlKzIqdGhpcy5ibHVyfSxuLnByb3RvdHlwZS5fdXBkYXRlVGFyZ2V0VHJhbnNmb3JtPWZ1bmN0aW9uKCl7dGhpcy50YXJnZXRUcmFuc2Zvcm0udHg9dGhpcy5kaXN0YW5jZSpNYXRoLmNvcyh0aGlzLmFuZ2xlKSx0aGlzLnRhcmdldFRyYW5zZm9ybS50eT10aGlzLmRpc3RhbmNlKk1hdGguc2luKHRoaXMuYW5nbGUpfSxyLnJlc29sdXRpb24uZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Jlc29sdXRpb259LHIucmVzb2x1dGlvbi5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fcmVzb2x1dGlvbj1lLHRoaXMuX3RpbnRGaWx0ZXImJih0aGlzLl90aW50RmlsdGVyLnJlc29sdXRpb249ZSksdGhpcy5fYmx1ckZpbHRlciYmKHRoaXMuX2JsdXJGaWx0ZXIucmVzb2x1dGlvbj1lKX0sci5kaXN0YW5jZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9LHIuZGlzdGFuY2Uuc2V0PWZ1bmN0aW9uKGUpe3RoaXMuX2Rpc3RhbmNlPWUsdGhpcy5fdXBkYXRlUGFkZGluZygpLHRoaXMuX3VwZGF0ZVRhcmdldFRyYW5zZm9ybSgpfSxyLnJvdGF0aW9uLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFuZ2xlL3QuREVHX1RPX1JBRH0sci5yb3RhdGlvbi5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5hbmdsZT1lKnQuREVHX1RPX1JBRCx0aGlzLl91cGRhdGVUYXJnZXRUcmFuc2Zvcm0oKX0sci5hbHBoYS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGludEZpbHRlci51bmlmb3Jtcy5hbHBoYX0sci5hbHBoYS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fdGludEZpbHRlci51bmlmb3Jtcy5hbHBoYT1lfSxyLmNvbG9yLmdldD1mdW5jdGlvbigpe3JldHVybiB0LnV0aWxzLnJnYjJoZXgodGhpcy5fdGludEZpbHRlci51bmlmb3Jtcy5jb2xvcil9LHIuY29sb3Iuc2V0PWZ1bmN0aW9uKGUpe3QudXRpbHMuaGV4MnJnYihlLHRoaXMuX3RpbnRGaWx0ZXIudW5pZm9ybXMuY29sb3IpfSxyLmtlcm5lbHMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIua2VybmVsc30sci5rZXJuZWxzLnNldD1mdW5jdGlvbihlKXt0aGlzLl9ibHVyRmlsdGVyLmtlcm5lbHM9ZX0sci5ibHVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ibHVyRmlsdGVyLmJsdXJ9LHIuYmx1ci5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fYmx1ckZpbHRlci5ibHVyPWUsdGhpcy5fdXBkYXRlUGFkZGluZygpfSxyLnF1YWxpdHkuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIucXVhbGl0eX0sci5xdWFsaXR5LnNldD1mdW5jdGlvbihlKXt0aGlzLl9ibHVyRmlsdGVyLnF1YWxpdHk9ZX0sci5waXhlbFNpemUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JsdXJGaWx0ZXIucGl4ZWxTaXplfSxyLnBpeGVsU2l6ZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fYmx1ckZpbHRlci5waXhlbFNpemU9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobi5wcm90b3R5cGUsciksbn0odC5GaWx0ZXIpLFo9bixWPVwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG5cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuXFx0dmVjMiBvbmVQaXhlbCA9IHZlYzIoMS4wIC8gZmlsdGVyQXJlYSk7XFxuXFxuXFx0dmVjNCBjb2xvcjtcXG5cXG5cXHRjb2xvci5yZ2IgPSB2ZWMzKDAuNSk7XFxuXFxuXFx0Y29sb3IgLT0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkIC0gb25lUGl4ZWwpICogc3RyZW5ndGg7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgb25lUGl4ZWwpICogc3RyZW5ndGg7XFxuXFxuXFx0Y29sb3IucmdiID0gdmVjMygoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMCk7XFxuXFxuXFx0ZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpLmE7XFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvci5yZ2IgKiBhbHBoYSwgYWxwaGEpO1xcbn1cXG5cIixIPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9NSksZS5jYWxsKHRoaXMsWixWKSx0aGlzLnN0cmVuZ3RoPXR9ZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQ7dmFyIG49e3N0cmVuZ3RoOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5zdHJlbmd0aC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5zdHJlbmd0aH0sbi5zdHJlbmd0aC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5zdHJlbmd0aD1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksJD1uLEo9XCIvLyBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckNsYW1wO1xcbnVuaWZvcm0gdmVjMiBkaW1lbnNpb25zO1xcbnVuaWZvcm0gZmxvYXQgYXNwZWN0O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG51bmlmb3JtIGZsb2F0IG9mZnNldDtcXG51bmlmb3JtIGZsb2F0IHNpbkRpcjtcXG51bmlmb3JtIGZsb2F0IGNvc0RpcjtcXG51bmlmb3JtIGludCBmaWxsTW9kZTtcXG5cXG51bmlmb3JtIGZsb2F0IHNlZWQ7XFxudW5pZm9ybSB2ZWMyIHJlZDtcXG51bmlmb3JtIHZlYzIgZ3JlZW47XFxudW5pZm9ybSB2ZWMyIGJsdWU7XFxuXFxuY29uc3QgaW50IFRSQU5TUEFSRU5UID0gMDtcXG5jb25zdCBpbnQgT1JJR0lOQUwgPSAxO1xcbmNvbnN0IGludCBMT09QID0gMjtcXG5jb25zdCBpbnQgQ0xBTVAgPSAzO1xcbmNvbnN0IGludCBNSVJST1IgPSA0O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjMiBjb29yZCA9ICh2VGV4dHVyZUNvb3JkICogZmlsdGVyQXJlYS54eSkgLyBkaW1lbnNpb25zO1xcblxcbiAgICBpZiAoY29vcmQueCA+IDEuMCB8fCBjb29yZC55ID4gMS4wKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgY3ggPSBjb29yZC54IC0gMC41O1xcbiAgICBmbG9hdCBjeSA9IChjb29yZC55IC0gMC41KSAqIGFzcGVjdDtcXG4gICAgZmxvYXQgbnkgPSAoLXNpbkRpciAqIGN4ICsgY29zRGlyICogY3kpIC8gYXNwZWN0ICsgMC41O1xcblxcbiAgICAvLyBkaXNwbGFjZW1lbnRNYXA6IHJlcGVhdFxcbiAgICAvLyBueSA9IG55ID4gMS4wID8gbnkgLSAxLjAgOiAobnkgPCAwLjAgPyAxLjAgKyBueSA6IG55KTtcXG5cXG4gICAgLy8gZGlzcGxhY2VtZW50TWFwOiBtaXJyb3JcXG4gICAgbnkgPSBueSA+IDEuMCA/IDIuMCAtIG55IDogKG55IDwgMC4wID8gLW55IDogbnkpO1xcblxcbiAgICB2ZWM0IGRjID0gdGV4dHVyZTJEKGRpc3BsYWNlbWVudE1hcCwgdmVjMigwLjUsIG55KSk7XFxuXFxuICAgIGZsb2F0IGRpc3BsYWNlbWVudCA9IChkYy5yIC0gZGMuZykgKiAob2Zmc2V0IC8gZmlsdGVyQXJlYS54KTtcXG5cXG4gICAgY29vcmQgPSB2VGV4dHVyZUNvb3JkICsgdmVjMihjb3NEaXIgKiBkaXNwbGFjZW1lbnQsIHNpbkRpciAqIGRpc3BsYWNlbWVudCAqIGFzcGVjdCk7XFxuXFxuICAgIGlmIChmaWxsTW9kZSA9PSBDTEFNUCkge1xcbiAgICAgICAgY29vcmQgPSBjbGFtcChjb29yZCwgZmlsdGVyQ2xhbXAueHksIGZpbHRlckNsYW1wLnp3KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGlmKCBjb29yZC54ID4gZmlsdGVyQ2xhbXAueiApIHtcXG4gICAgICAgICAgICBpZiAoZmlsbE1vZGUgPT0gT1JJR0lOQUwpIHtcXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICAgICAgICBjb29yZC54IC09IGZpbHRlckNsYW1wLno7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBNSVJST1IpIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueCA9IGZpbHRlckNsYW1wLnogKiAyLjAgLSBjb29yZC54O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmKCBjb29yZC54IDwgZmlsdGVyQ2xhbXAueCApIHtcXG4gICAgICAgICAgICBpZiAoZmlsbE1vZGUgPT0gT1JJR0lOQUwpIHtcXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICAgICAgICBjb29yZC54ICs9IGZpbHRlckNsYW1wLno7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBNSVJST1IpIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueCAqPSAtZmlsdGVyQ2xhbXAuejtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmKCBjb29yZC55ID4gZmlsdGVyQ2xhbXAudyApIHtcXG4gICAgICAgICAgICBpZiAoZmlsbE1vZGUgPT0gT1JJR0lOQUwpIHtcXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICAgICAgICBjb29yZC55IC09IGZpbHRlckNsYW1wLnc7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBNSVJST1IpIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueSA9IGZpbHRlckNsYW1wLncgKiAyLjAgLSBjb29yZC55O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sIDAuLCAwLiwgMC4pO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmKCBjb29yZC55IDwgZmlsdGVyQ2xhbXAueSApIHtcXG4gICAgICAgICAgICBpZiAoZmlsbE1vZGUgPT0gT1JJR0lOQUwpIHtcXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsbE1vZGUgPT0gTE9PUCkge1xcbiAgICAgICAgICAgICAgICBjb29yZC55ICs9IGZpbHRlckNsYW1wLnc7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsTW9kZSA9PSBNSVJST1IpIHtcXG4gICAgICAgICAgICAgICAgY29vcmQueSAqPSAtZmlsdGVyQ2xhbXAudztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IuciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQgKyByZWQgKiAoMS4wIC0gc2VlZCAqIDAuNCkgLyBmaWx0ZXJBcmVhLnh5KS5yO1xcbiAgICBnbF9GcmFnQ29sb3IuZyA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQgKyBncmVlbiAqICgxLjAgLSBzZWVkICogMC4zKSAvIGZpbHRlckFyZWEueHkpLmc7XFxuICAgIGdsX0ZyYWdDb2xvci5iID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCArIGJsdWUgKiAoMS4wIC0gc2VlZCAqIDAuMikgLyBmaWx0ZXJBcmVhLnh5KS5iO1xcbiAgICBnbF9GcmFnQ29sb3IuYSA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpLmE7XFxufVxcblwiLGVlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4obil7dm9pZCAwPT09biYmKG49e30pLGUuY2FsbCh0aGlzLCQsSiksdGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zPW5ldyBGbG9hdDMyQXJyYXkoMiksbj1PYmplY3QuYXNzaWduKHtzbGljZXM6NSxvZmZzZXQ6MTAwLGRpcmVjdGlvbjowLGZpbGxNb2RlOjAsYXZlcmFnZTohMSxzZWVkOjAscmVkOlswLDBdLGdyZWVuOlswLDBdLGJsdWU6WzAsMF0sbWluU2l6ZTo4LHNhbXBsZVNpemU6NTEyfSxuKSx0aGlzLmRpcmVjdGlvbj1uLmRpcmVjdGlvbix0aGlzLnJlZD1uLnJlZCx0aGlzLmdyZWVuPW4uZ3JlZW4sdGhpcy5ibHVlPW4uYmx1ZSx0aGlzLm9mZnNldD1uLm9mZnNldCx0aGlzLmZpbGxNb2RlPW4uZmlsbE1vZGUsdGhpcy5hdmVyYWdlPW4uYXZlcmFnZSx0aGlzLnNlZWQ9bi5zZWVkLHRoaXMubWluU2l6ZT1uLm1pblNpemUsdGhpcy5zYW1wbGVTaXplPW4uc2FtcGxlU2l6ZSx0aGlzLl9jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSx0aGlzLl9jYW52YXMud2lkdGg9NCx0aGlzLl9jYW52YXMuaGVpZ2h0PXRoaXMuc2FtcGxlU2l6ZSx0aGlzLnRleHR1cmU9dC5UZXh0dXJlLmZyb21DYW52YXModGhpcy5fY2FudmFzLHQuU0NBTEVfTU9ERVMuTkVBUkVTVCksdGhpcy5fc2xpY2VzPTAsdGhpcy5zbGljZXM9bi5zbGljZXN9ZSYmKG4uX19wcm90b19fPWUpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW47dmFyIHI9e3NpemVzOntjb25maWd1cmFibGU6ITB9LG9mZnNldHM6e2NvbmZpZ3VyYWJsZTohMH0sc2xpY2VzOntjb25maWd1cmFibGU6ITB9LGRpcmVjdGlvbjp7Y29uZmlndXJhYmxlOiEwfSxyZWQ6e2NvbmZpZ3VyYWJsZTohMH0sZ3JlZW46e2NvbmZpZ3VyYWJsZTohMH0sYmx1ZTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBvPXQuc291cmNlRnJhbWUud2lkdGgsaT10LnNvdXJjZUZyYW1lLmhlaWdodDt0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnNbMF09byx0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnNbMV09aSx0aGlzLnVuaWZvcm1zLmFzcGVjdD1pL28sdGhpcy51bmlmb3Jtcy5zZWVkPXRoaXMuc2VlZCx0aGlzLnVuaWZvcm1zLm9mZnNldD10aGlzLm9mZnNldCx0aGlzLnVuaWZvcm1zLmZpbGxNb2RlPXRoaXMuZmlsbE1vZGUsZS5hcHBseUZpbHRlcih0aGlzLHQsbixyKX0sbi5wcm90b3R5cGUuX3JhbmRvbWl6ZVNpemVzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fc2l6ZXMsdD10aGlzLl9zbGljZXMtMSxuPXRoaXMuc2FtcGxlU2l6ZSxyPU1hdGgubWluKHRoaXMubWluU2l6ZS9uLC45L3RoaXMuX3NsaWNlcyk7aWYodGhpcy5hdmVyYWdlKXtmb3IodmFyIG89dGhpcy5fc2xpY2VzLGk9MSxsPTA7bDx0O2wrKyl7dmFyIHM9aS8oby1sKSxhPU1hdGgubWF4KHMqKDEtLjYqTWF0aC5yYW5kb20oKSkscik7ZVtsXT1hLGktPWF9ZVt0XT1pfWVsc2V7Zm9yKHZhciB1PTEsYz1NYXRoLnNxcnQoMS90aGlzLl9zbGljZXMpLGY9MDtmPHQ7ZisrKXt2YXIgaD1NYXRoLm1heChjKnUqTWF0aC5yYW5kb20oKSxyKTtlW2ZdPWgsdS09aH1lW3RdPXV9dGhpcy5zaHVmZmxlKCl9LG4ucHJvdG90eXBlLnNodWZmbGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5fc2l6ZXMsdD10aGlzLl9zbGljZXMtMTt0PjA7dC0tKXt2YXIgbj1NYXRoLnJhbmRvbSgpKnQ+PjAscj1lW3RdO2VbdF09ZVtuXSxlW25dPXJ9fSxuLnByb3RvdHlwZS5fcmFuZG9taXplT2Zmc2V0cz1mdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8dGhpcy5fc2xpY2VzO2UrKyl0aGlzLl9vZmZzZXRzW2VdPU1hdGgucmFuZG9tKCkqKE1hdGgucmFuZG9tKCk8LjU/LTE6MSl9LG4ucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt0aGlzLl9yYW5kb21pemVTaXplcygpLHRoaXMuX3JhbmRvbWl6ZU9mZnNldHMoKSx0aGlzLnJlZHJhdygpfSxuLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXMuc2FtcGxlU2l6ZSxuPXRoaXMudGV4dHVyZSxyPXRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7ci5jbGVhclJlY3QoMCwwLDgsdCk7Zm9yKHZhciBvPTAsaT0wO2k8dGhpcy5fc2xpY2VzO2krKyl7ZT1NYXRoLmZsb29yKDI1Nip0aGlzLl9vZmZzZXRzW2ldKTt2YXIgbD10aGlzLl9zaXplc1tpXSp0LHM9ZT4wP2U6MCxhPWU8MD8tZTowO3IuZmlsbFN0eWxlPVwicmdiYShcIitzK1wiLCBcIithK1wiLCAwLCAxKVwiLHIuZmlsbFJlY3QoMCxvPj4wLHQsbCsxPj4wKSxvKz1sfW4uYmFzZVRleHR1cmUudXBkYXRlKCksdGhpcy51bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXA9bn0sci5zaXplcy5zZXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PU1hdGgubWluKHRoaXMuX3NsaWNlcyxlLmxlbmd0aCksbj0wO248dDtuKyspdGhpcy5fc2l6ZXNbbl09ZVtuXX0sci5zaXplcy5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZXN9LHIub2Zmc2V0cy5zZXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PU1hdGgubWluKHRoaXMuX3NsaWNlcyxlLmxlbmd0aCksbj0wO248dDtuKyspdGhpcy5fb2Zmc2V0c1tuXT1lW25dfSxyLm9mZnNldHMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX29mZnNldHN9LHIuc2xpY2VzLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zbGljZXN9LHIuc2xpY2VzLnNldD1mdW5jdGlvbihlKXt0aGlzLl9zbGljZXMhPT1lJiYodGhpcy5fc2xpY2VzPWUsdGhpcy51bmlmb3Jtcy5zbGljZXM9ZSx0aGlzLl9zaXplcz10aGlzLnVuaWZvcm1zLnNsaWNlc1dpZHRoPW5ldyBGbG9hdDMyQXJyYXkoZSksdGhpcy5fb2Zmc2V0cz10aGlzLnVuaWZvcm1zLnNsaWNlc09mZnNldD1uZXcgRmxvYXQzMkFycmF5KGUpLHRoaXMucmVmcmVzaCgpKX0sci5kaXJlY3Rpb24uZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RpcmVjdGlvbn0sci5kaXJlY3Rpb24uc2V0PWZ1bmN0aW9uKGUpe2lmKHRoaXMuX2RpcmVjdGlvbiE9PWUpe3RoaXMuX2RpcmVjdGlvbj1lO3ZhciBuPWUqdC5ERUdfVE9fUkFEO3RoaXMudW5pZm9ybXMuc2luRGlyPU1hdGguc2luKG4pLHRoaXMudW5pZm9ybXMuY29zRGlyPU1hdGguY29zKG4pfX0sci5yZWQuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMucmVkfSxyLnJlZC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5yZWQ9ZX0sci5ncmVlbi5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5ncmVlbn0sci5ncmVlbi5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5ncmVlbj1lfSxyLmJsdWUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuYmx1ZX0sci5ibHVlLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmJsdWU9ZX0sbi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudGV4dHVyZS5kZXN0cm95KCEwKSx0aGlzLnRleHR1cmU9bnVsbCx0aGlzLl9jYW52YXM9bnVsbCx0aGlzLnJlZD1udWxsLHRoaXMuZ3JlZW49bnVsbCx0aGlzLmJsdWU9bnVsbCx0aGlzLl9zaXplcz1udWxsLHRoaXMuX29mZnNldHM9bnVsbH0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobi5wcm90b3R5cGUsciksbn0odC5GaWx0ZXIpO2VlLlRSQU5TUEFSRU5UPTAsZWUuT1JJR0lOQUw9MSxlZS5MT09QPTIsZWUuQ0xBTVA9MyxlZS5NSVJST1I9NDt2YXIgdGU9bixuZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudW5pZm9ybSBmbG9hdCBkaXN0YW5jZTtcXG51bmlmb3JtIGZsb2F0IG91dGVyU3RyZW5ndGg7XFxudW5pZm9ybSBmbG9hdCBpbm5lclN0cmVuZ3RoO1xcbnVuaWZvcm0gdmVjNCBnbG93Q29sb3I7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckNsYW1wO1xcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWMyIHB4ID0gdmVjMigxLjAgLyBmaWx0ZXJBcmVhLngsIDEuMCAvIGZpbHRlckFyZWEueSk7XFxuICAgIHZlYzQgb3duQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWM0IGN1ckNvbG9yO1xcbiAgICBmbG9hdCB0b3RhbEFscGhhID0gMC4wO1xcbiAgICBmbG9hdCBtYXhUb3RhbEFscGhhID0gMC4wO1xcbiAgICBmbG9hdCBjb3NBbmdsZTtcXG4gICAgZmxvYXQgc2luQW5nbGU7XFxuICAgIHZlYzIgZGlzcGxhY2VkO1xcbiAgICBmb3IgKGZsb2F0IGFuZ2xlID0gMC4wOyBhbmdsZSA8PSBQSSAqIDIuMDsgYW5nbGUgKz0gJVFVQUxJVFlfRElTVCUpIHtcXG4gICAgICAgY29zQW5nbGUgPSBjb3MoYW5nbGUpO1xcbiAgICAgICBzaW5BbmdsZSA9IHNpbihhbmdsZSk7XFxuICAgICAgIGZvciAoZmxvYXQgY3VyRGlzdGFuY2UgPSAxLjA7IGN1ckRpc3RhbmNlIDw9ICVESVNUJTsgY3VyRGlzdGFuY2UrKykge1xcbiAgICAgICAgICAgZGlzcGxhY2VkLnggPSB2VGV4dHVyZUNvb3JkLnggKyBjb3NBbmdsZSAqIGN1ckRpc3RhbmNlICogcHgueDtcXG4gICAgICAgICAgIGRpc3BsYWNlZC55ID0gdlRleHR1cmVDb29yZC55ICsgc2luQW5nbGUgKiBjdXJEaXN0YW5jZSAqIHB4Lnk7XFxuICAgICAgICAgICBjdXJDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAoZGlzcGxhY2VkLCBmaWx0ZXJDbGFtcC54eSwgZmlsdGVyQ2xhbXAuencpKTtcXG4gICAgICAgICAgIHRvdGFsQWxwaGEgKz0gKGRpc3RhbmNlIC0gY3VyRGlzdGFuY2UpICogY3VyQ29sb3IuYTtcXG4gICAgICAgICAgIG1heFRvdGFsQWxwaGEgKz0gKGRpc3RhbmNlIC0gY3VyRGlzdGFuY2UpO1xcbiAgICAgICB9XFxuICAgIH1cXG4gICAgbWF4VG90YWxBbHBoYSA9IG1heChtYXhUb3RhbEFscGhhLCAwLjAwMDEpO1xcblxcbiAgICBvd25Db2xvci5hID0gbWF4KG93bkNvbG9yLmEsIDAuMDAwMSk7XFxuICAgIG93bkNvbG9yLnJnYiA9IG93bkNvbG9yLnJnYiAvIG93bkNvbG9yLmE7XFxuICAgIGZsb2F0IG91dGVyR2xvd0FscGhhID0gKHRvdGFsQWxwaGEgLyBtYXhUb3RhbEFscGhhKSAgKiBvdXRlclN0cmVuZ3RoICogKDEuIC0gb3duQ29sb3IuYSk7XFxuICAgIGZsb2F0IGlubmVyR2xvd0FscGhhID0gKChtYXhUb3RhbEFscGhhIC0gdG90YWxBbHBoYSkgLyBtYXhUb3RhbEFscGhhKSAqIGlubmVyU3RyZW5ndGggKiBvd25Db2xvci5hO1xcbiAgICBmbG9hdCByZXN1bHRBbHBoYSA9IChvd25Db2xvci5hICsgb3V0ZXJHbG93QWxwaGEpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChtaXgob3duQ29sb3IucmdiLCBnbG93Q29sb3IucmdiLCBpbm5lckdsb3dBbHBoYSAvIG93bkNvbG9yLmEpLCBnbG93Q29sb3IucmdiLCBvdXRlckdsb3dBbHBoYSAvIHJlc3VsdEFscGhhKSAqIHJlc3VsdEFscGhhLCByZXN1bHRBbHBoYSk7XFxufVxcblwiLHJlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxuLHIsbyxpKXt2b2lkIDA9PT10JiYodD0xMCksdm9pZCAwPT09biYmKG49NCksdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89MTY3NzcyMTUpLHZvaWQgMD09PWkmJihpPS4xKSxlLmNhbGwodGhpcyx0ZSxuZS5yZXBsYWNlKC8lUVVBTElUWV9ESVNUJS9naSxcIlwiKygxL2kvdCkudG9GaXhlZCg3KSkucmVwbGFjZSgvJURJU1QlL2dpLFwiXCIrdC50b0ZpeGVkKDcpKSksdGhpcy51bmlmb3Jtcy5nbG93Q29sb3I9bmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMV0pLHRoaXMuZGlzdGFuY2U9dCx0aGlzLmNvbG9yPW8sdGhpcy5vdXRlclN0cmVuZ3RoPW4sdGhpcy5pbm5lclN0cmVuZ3RoPXJ9ZSYmKG4uX19wcm90b19fPWUpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW47dmFyIHI9e2NvbG9yOntjb25maWd1cmFibGU6ITB9LGRpc3RhbmNlOntjb25maWd1cmFibGU6ITB9LG91dGVyU3RyZW5ndGg6e2NvbmZpZ3VyYWJsZTohMH0saW5uZXJTdHJlbmd0aDp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIHIuY29sb3IuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHQudXRpbHMucmdiMmhleCh0aGlzLnVuaWZvcm1zLmdsb3dDb2xvcil9LHIuY29sb3Iuc2V0PWZ1bmN0aW9uKGUpe3QudXRpbHMuaGV4MnJnYihlLHRoaXMudW5pZm9ybXMuZ2xvd0NvbG9yKX0sci5kaXN0YW5jZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5kaXN0YW5jZX0sci5kaXN0YW5jZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5kaXN0YW5jZT1lfSxyLm91dGVyU3RyZW5ndGguZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMub3V0ZXJTdHJlbmd0aH0sci5vdXRlclN0cmVuZ3RoLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLm91dGVyU3RyZW5ndGg9ZX0sci5pbm5lclN0cmVuZ3RoLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmlubmVyU3RyZW5ndGh9LHIuaW5uZXJTdHJlbmd0aC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5pbm5lclN0cmVuZ3RoPWV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG4ucHJvdG90eXBlLHIpLG59KHQuRmlsdGVyKSxvZT1uLGllPVwidmVjMyBtb2QyODkodmVjMyB4KVxcbntcXG4gICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxudmVjNCBtb2QyODkodmVjNCB4KVxcbntcXG4gICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxudmVjNCBwZXJtdXRlKHZlYzQgeClcXG57XFxuICAgIHJldHVybiBtb2QyODkoKCh4ICogMzQuMCkgKyAxLjApICogeCk7XFxufVxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpXFxue1xcbiAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG52ZWMzIGZhZGUodmVjMyB0KVxcbntcXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2LjAgLSAxNS4wKSArIDEwLjApO1xcbn1cXG4vLyBDbGFzc2ljIFBlcmxpbiBub2lzZSwgcGVyaW9kaWMgdmFyaWFudFxcbmZsb2F0IHBub2lzZSh2ZWMzIFAsIHZlYzMgcmVwKVxcbntcXG4gICAgdmVjMyBQaTAgPSBtb2QoZmxvb3IoUCksIHJlcCk7IC8vIEludGVnZXIgcGFydCwgbW9kdWxvIHBlcmlvZFxcbiAgICB2ZWMzIFBpMSA9IG1vZChQaTAgKyB2ZWMzKDEuMCksIHJlcCk7IC8vIEludGVnZXIgcGFydCArIDEsIG1vZCBwZXJpb2RcXG4gICAgUGkwID0gbW9kMjg5KFBpMCk7XFxuICAgIFBpMSA9IG1vZDI4OShQaTEpO1xcbiAgICB2ZWMzIFBmMCA9IGZyYWN0KFApOyAvLyBGcmFjdGlvbmFsIHBhcnQgZm9yIGludGVycG9sYXRpb25cXG4gICAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcbiAgICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICAgIHZlYzQgaXkgPSB2ZWM0KFBpMC55eSwgUGkxLnl5KTtcXG4gICAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG4gICAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG4gICAgdmVjNCBpeHkgPSBwZXJtdXRlKHBlcm11dGUoaXgpICsgaXkpO1xcbiAgICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XFxuICAgIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG4gICAgdmVjNCBneDAgPSBpeHkwICogKDEuMCAvIDcuMCk7XFxuICAgIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcXG4gICAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gICAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcbiAgICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xcbiAgICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG4gICAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XFxuICAgIHZlYzQgZ3gxID0gaXh5MSAqICgxLjAgLyA3LjApO1xcbiAgICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XFxuICAgIGd4MSA9IGZyYWN0KGd4MSk7XFxuICAgIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gICAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcXG4gICAgZ3gxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3gxKSAtIDAuNSk7XFxuICAgIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcbiAgICB2ZWMzIGcwMDAgPSB2ZWMzKGd4MC54LCBneTAueCwgZ3owLngpO1xcbiAgICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LCBneTAueSwgZ3owLnkpO1xcbiAgICB2ZWMzIGcwMTAgPSB2ZWMzKGd4MC56LCBneTAueiwgZ3owLnopO1xcbiAgICB2ZWMzIGcxMTAgPSB2ZWMzKGd4MC53LCBneTAudywgZ3owLncpO1xcbiAgICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LCBneTEueCwgZ3oxLngpO1xcbiAgICB2ZWMzIGcxMDEgPSB2ZWMzKGd4MS55LCBneTEueSwgZ3oxLnkpO1xcbiAgICB2ZWMzIGcwMTEgPSB2ZWMzKGd4MS56LCBneTEueiwgZ3oxLnopO1xcbiAgICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LCBneTEudywgZ3oxLncpO1xcbiAgICB2ZWM0IG5vcm0wID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAwLCBnMDAwKSwgZG90KGcwMTAsIGcwMTApLCBkb3QoZzEwMCwgZzEwMCksIGRvdChnMTEwLCBnMTEwKSkpO1xcbiAgICBnMDAwICo9IG5vcm0wLng7XFxuICAgIGcwMTAgKj0gbm9ybTAueTtcXG4gICAgZzEwMCAqPSBub3JtMC56O1xcbiAgICBnMTEwICo9IG5vcm0wLnc7XFxuICAgIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XFxuICAgIGcwMDEgKj0gbm9ybTEueDtcXG4gICAgZzAxMSAqPSBub3JtMS55O1xcbiAgICBnMTAxICo9IG5vcm0xLno7XFxuICAgIGcxMTEgKj0gbm9ybTEudztcXG4gICAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgICBmbG9hdCBuMTAwID0gZG90KGcxMDAsIHZlYzMoUGYxLngsIFBmMC55eikpO1xcbiAgICBmbG9hdCBuMDEwID0gZG90KGcwMTAsIHZlYzMoUGYwLngsIFBmMS55LCBQZjAueikpO1xcbiAgICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgICBmbG9hdCBuMDAxID0gZG90KGcwMDEsIHZlYzMoUGYwLnh5LCBQZjEueikpO1xcbiAgICBmbG9hdCBuMTAxID0gZG90KGcxMDEsIHZlYzMoUGYxLngsIFBmMC55LCBQZjEueikpO1xcbiAgICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgICBmbG9hdCBuMTExID0gZG90KGcxMTEsIFBmMSk7XFxuICAgIHZlYzMgZmFkZV94eXogPSBmYWRlKFBmMCk7XFxuICAgIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcbiAgICBmbG9hdCBuX3h5eiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7XFxuICAgIHJldHVybiAyLjIgKiBuX3h5ejtcXG59XFxuZmxvYXQgdHVyYih2ZWMzIFAsIHZlYzMgcmVwLCBmbG9hdCBsYWN1bmFyaXR5LCBmbG9hdCBnYWluKVxcbntcXG4gICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICBmbG9hdCBzYyA9IDEuMDtcXG4gICAgZmxvYXQgdG90YWxnYWluID0gMS4wO1xcbiAgICBmb3IgKGZsb2F0IGkgPSAwLjA7IGkgPCA2LjA7IGkrKylcXG4gICAge1xcbiAgICAgICAgc3VtICs9IHRvdGFsZ2FpbiAqIHBub2lzZShQICogc2MsIHJlcCk7XFxuICAgICAgICBzYyAqPSBsYWN1bmFyaXR5O1xcbiAgICAgICAgdG90YWxnYWluICo9IGdhaW47XFxuICAgIH1cXG4gICAgcmV0dXJuIGFicyhzdW0pO1xcbn1cXG5cIixsZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCBmaWx0ZXJBcmVhO1xcbnVuaWZvcm0gdmVjMiBkaW1lbnNpb25zO1xcblxcbnVuaWZvcm0gdmVjMiBsaWdodDtcXG51bmlmb3JtIGJvb2wgcGFyYWxsZWw7XFxudW5pZm9ybSBmbG9hdCBhc3BlY3Q7XFxuXFxudW5pZm9ybSBmbG9hdCBnYWluO1xcbnVuaWZvcm0gZmxvYXQgbGFjdW5hcml0eTtcXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuXFxuJHtwZXJsaW59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKiBmaWx0ZXJBcmVhLnh5IC8gZGltZW5zaW9ucy54eTtcXG5cXG4gICAgZmxvYXQgZDtcXG5cXG4gICAgaWYgKHBhcmFsbGVsKSB7XFxuICAgICAgICBmbG9hdCBfY29zID0gbGlnaHQueDtcXG4gICAgICAgIGZsb2F0IF9zaW4gPSBsaWdodC55O1xcbiAgICAgICAgZCA9IChfY29zICogY29vcmQueCkgKyAoX3NpbiAqIGNvb3JkLnkgKiBhc3BlY3QpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZmxvYXQgZHggPSBjb29yZC54IC0gbGlnaHQueCAvIGRpbWVuc2lvbnMueDtcXG4gICAgICAgIGZsb2F0IGR5ID0gKGNvb3JkLnkgLSBsaWdodC55IC8gZGltZW5zaW9ucy55KSAqIGFzcGVjdDtcXG4gICAgICAgIGZsb2F0IGRpcyA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpICsgMC4wMDAwMTtcXG4gICAgICAgIGQgPSBkeSAvIGRpcztcXG4gICAgfVxcblxcbiAgICB2ZWMzIGRpciA9IHZlYzMoZCwgZCwgMC4wKTtcXG5cXG4gICAgZmxvYXQgbm9pc2UgPSB0dXJiKGRpciArIHZlYzModGltZSwgMC4wLCA2Mi4xICsgdGltZSkgKiAwLjA1LCB2ZWMzKDQ4MC4wLCAzMjAuMCwgNDgwLjApLCBsYWN1bmFyaXR5LCBnYWluKTtcXG4gICAgbm9pc2UgPSBtaXgobm9pc2UsIDAuMCwgMC4zKTtcXG4gICAgLy9mYWRlIHZlcnRpY2FsbHkuXFxuICAgIHZlYzQgbWlzdCA9IHZlYzQobm9pc2UsIG5vaXNlLCBub2lzZSwgMS4wKSAqICgxLjAgLSBjb29yZC55KTtcXG4gICAgbWlzdC5hID0gMS4wO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICsgbWlzdDtcXG59XFxuXCIsc2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihuKXtlLmNhbGwodGhpcyxvZSxsZS5yZXBsYWNlKFwiJHtwZXJsaW59XCIsaWUpKSx0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnM9bmV3IEZsb2F0MzJBcnJheSgyKSxcIm51bWJlclwiPT10eXBlb2YgbiYmKGNvbnNvbGUud2FybihcIkdvZHJheUZpbHRlciBub3cgdXNlcyBvcHRpb25zIGluc3RlYWQgb2YgKGFuZ2xlLCBnYWluLCBsYWN1bmFyaXR5LCB0aW1lKVwiKSxuPXthbmdsZTpufSx2b2lkIDAhPT1hcmd1bWVudHNbMV0mJihuLmdhaW49YXJndW1lbnRzWzFdKSx2b2lkIDAhPT1hcmd1bWVudHNbMl0mJihuLmxhY3VuYXJpdHk9YXJndW1lbnRzWzJdKSx2b2lkIDAhPT1hcmd1bWVudHNbM10mJihuLnRpbWU9YXJndW1lbnRzWzNdKSksbj1PYmplY3QuYXNzaWduKHthbmdsZTozMCxnYWluOi41LGxhY3VuYXJpdHk6Mi41LHRpbWU6MCxwYXJhbGxlbDohMCxjZW50ZXI6WzAsMF19LG4pLHRoaXMuX2FuZ2xlTGlnaHQ9bmV3IHQuUG9pbnQsdGhpcy5hbmdsZT1uLmFuZ2xlLHRoaXMuZ2Fpbj1uLmdhaW4sdGhpcy5sYWN1bmFyaXR5PW4ubGFjdW5hcml0eSx0aGlzLnBhcmFsbGVsPW4ucGFyYWxsZWwsdGhpcy5jZW50ZXI9bi5jZW50ZXIsdGhpcy50aW1lPW4udGltZX1lJiYobi5fX3Byb3RvX189ZSksbi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bjt2YXIgcj17YW5nbGU6e2NvbmZpZ3VyYWJsZTohMH0sZ2Fpbjp7Y29uZmlndXJhYmxlOiEwfSxsYWN1bmFyaXR5Ontjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89dC5zb3VyY2VGcmFtZSxpPW8ud2lkdGgsbD1vLmhlaWdodDt0aGlzLnVuaWZvcm1zLmxpZ2h0PXRoaXMucGFyYWxsZWw/dGhpcy5fYW5nbGVMaWdodDp0aGlzLmNlbnRlcix0aGlzLnVuaWZvcm1zLnBhcmFsbGVsPXRoaXMucGFyYWxsZWwsdGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zWzBdPWksdGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zWzFdPWwsdGhpcy51bmlmb3Jtcy5hc3BlY3Q9bC9pLHRoaXMudW5pZm9ybXMudGltZT10aGlzLnRpbWUsZS5hcHBseUZpbHRlcih0aGlzLHQsbixyKX0sci5hbmdsZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYW5nbGV9LHIuYW5nbGUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMuX2FuZ2xlPWU7dmFyIG49ZSp0LkRFR19UT19SQUQ7dGhpcy5fYW5nbGVMaWdodC54PU1hdGguY29zKG4pLHRoaXMuX2FuZ2xlTGlnaHQueT1NYXRoLnNpbihuKX0sci5nYWluLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmdhaW59LHIuZ2Fpbi5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5nYWluPWV9LHIubGFjdW5hcml0eS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5sYWN1bmFyaXR5fSxyLmxhY3VuYXJpdHkuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMubGFjdW5hcml0eT1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksYWU9bix1ZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCBmaWx0ZXJBcmVhO1xcblxcbnVuaWZvcm0gdmVjMiB1VmVsb2NpdHk7XFxudW5pZm9ybSBpbnQgdUtlcm5lbFNpemU7XFxudW5pZm9ybSBmbG9hdCB1T2Zmc2V0O1xcblxcbmNvbnN0IGludCBNQVhfS0VSTkVMX1NJWkUgPSAyMDQ4O1xcblxcbi8vIE5vdGljZTpcXG4vLyB0aGUgcGVyZmVjdCB3YXk6XFxuLy8gICAgaW50IGtlcm5lbFNpemUgPSBtaW4odUtlcm5lbFNpemUsIE1BWF9LRVJORUxTSVpFKTtcXG4vLyBCVVQgaW4gcmVhbCB1c2UtY2FzZSAsIHVLZXJuZWxTaXplIDwgTUFYX0tFUk5FTFNJWkUgYWxtb3N0IGFsd2F5cy5cXG4vLyBTbyB1c2UgdUtlcm5lbFNpemUgZGlyZWN0bHkuXFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgaWYgKHVLZXJuZWxTaXplID09IDApXFxuICAgIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZlYzIgdmVsb2NpdHkgPSB1VmVsb2NpdHkgLyBmaWx0ZXJBcmVhLnh5O1xcbiAgICBmbG9hdCBvZmZzZXQgPSAtdU9mZnNldCAvIGxlbmd0aCh1VmVsb2NpdHkpIC0gMC41O1xcbiAgICBpbnQgayA9IHVLZXJuZWxTaXplIC0gMTtcXG5cXG4gICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9LRVJORUxfU0laRSAtIDE7IGkrKykge1xcbiAgICAgICAgaWYgKGkgPT0gaykge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmVjMiBiaWFzID0gdmVsb2NpdHkgKiAoZmxvYXQoaSkgLyBmbG9hdChrKSArIG9mZnNldCk7XFxuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBiaWFzKTtcXG4gICAgfVxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIGZsb2F0KHVLZXJuZWxTaXplKTtcXG59XFxuXCIsY2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihuLHIsbyl7dm9pZCAwPT09biYmKG49WzAsMF0pLHZvaWQgMD09PXImJihyPTUpLHZvaWQgMD09PW8mJihvPTApLGUuY2FsbCh0aGlzLGFlLHVlKSx0aGlzLnVuaWZvcm1zLnVWZWxvY2l0eT1uZXcgRmxvYXQzMkFycmF5KDIpLHRoaXMuX3ZlbG9jaXR5PW5ldyB0Lk9ic2VydmFibGVQb2ludCh0aGlzLnZlbG9jaXR5Q2hhbmdlZCx0aGlzKSx0aGlzLnZlbG9jaXR5PW4sdGhpcy5rZXJuZWxTaXplPXIsdGhpcy5vZmZzZXQ9b31lJiYobi5fX3Byb3RvX189ZSksbi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksbi5wcm90b3R5cGUuY29uc3RydWN0b3I9bjt2YXIgcj17dmVsb2NpdHk6e2NvbmZpZ3VyYWJsZTohMH0sb2Zmc2V0Ontjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89dGhpcy52ZWxvY2l0eSxpPW8ueCxsPW8ueTt0aGlzLnVuaWZvcm1zLnVLZXJuZWxTaXplPTAhPT1pfHwwIT09bD90aGlzLmtlcm5lbFNpemU6MCxlLmFwcGx5RmlsdGVyKHRoaXMsdCxuLHIpfSxyLnZlbG9jaXR5LnNldD1mdW5jdGlvbihlKXtBcnJheS5pc0FycmF5KGUpP3RoaXMuX3ZlbG9jaXR5LnNldChlWzBdLGVbMV0pOihlIGluc3RhbmNlb2YgdC5Qb2ludHx8ZSBpbnN0YW5jZW9mIHQuT2JzZXJ2YWJsZVBvaW50KSYmdGhpcy5fdmVsb2NpdHkuY29weShlKX0sci52ZWxvY2l0eS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmVsb2NpdHl9LG4ucHJvdG90eXBlLnZlbG9jaXR5Q2hhbmdlZD1mdW5jdGlvbigpe3RoaXMudW5pZm9ybXMudVZlbG9jaXR5WzBdPXRoaXMuX3ZlbG9jaXR5LngsdGhpcy51bmlmb3Jtcy51VmVsb2NpdHlbMV09dGhpcy5fdmVsb2NpdHkueX0sci5vZmZzZXQuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMudU9mZnNldD1lfSxyLm9mZnNldC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy51T2Zmc2V0fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksZmU9bixoZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnVuaWZvcm0gZmxvYXQgZXBzaWxvbjtcXG5cXG5jb25zdCBpbnQgTUFYX0NPTE9SUyA9ICVtYXhDb2xvcnMlO1xcblxcbnVuaWZvcm0gdmVjMyBvcmlnaW5hbENvbG9yc1tNQVhfQ09MT1JTXTtcXG51bmlmb3JtIHZlYzMgdGFyZ2V0Q29sb3JzW01BWF9DT0xPUlNdO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgZmxvYXQgYWxwaGEgPSBnbF9GcmFnQ29sb3IuYTtcXG4gICAgaWYgKGFscGhhIDwgMC4wMDAxKVxcbiAgICB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZlYzMgY29sb3IgPSBnbF9GcmFnQ29sb3IucmdiIC8gYWxwaGE7XFxuXFxuICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfQ09MT1JTOyBpKyspXFxuICAgIHtcXG4gICAgICB2ZWMzIG9yaWdDb2xvciA9IG9yaWdpbmFsQ29sb3JzW2ldO1xcbiAgICAgIGlmIChvcmlnQ29sb3IuciA8IDAuMClcXG4gICAgICB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgICAgdmVjMyBjb2xvckRpZmYgPSBvcmlnQ29sb3IgLSBjb2xvcjtcXG4gICAgICBpZiAobGVuZ3RoKGNvbG9yRGlmZikgPCBlcHNpbG9uKVxcbiAgICAgIHtcXG4gICAgICAgIHZlYzMgdGFyZ2V0Q29sb3IgPSB0YXJnZXRDb2xvcnNbaV07XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCh0YXJnZXRDb2xvciArIGNvbG9yRGlmZikgKiBhbHBoYSwgYWxwaGEpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfVxcbn1cXG5cIixwZT1mdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsbixyKXt2b2lkIDA9PT1uJiYobj0uMDUpLHZvaWQgMD09PXImJihyPW51bGwpLHI9cnx8dC5sZW5ndGgsZS5jYWxsKHRoaXMsZmUsaGUucmVwbGFjZSgvJW1heENvbG9ycyUvZyxyKSksdGhpcy5lcHNpbG9uPW4sdGhpcy5fbWF4Q29sb3JzPXIsdGhpcy5fcmVwbGFjZW1lbnRzPW51bGwsdGhpcy51bmlmb3Jtcy5vcmlnaW5hbENvbG9ycz1uZXcgRmxvYXQzMkFycmF5KDMqciksdGhpcy51bmlmb3Jtcy50YXJnZXRDb2xvcnM9bmV3IEZsb2F0MzJBcnJheSgzKnIpLHRoaXMucmVwbGFjZW1lbnRzPXR9ZSYmKG4uX19wcm90b19fPWUpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW47dmFyIHI9e3JlcGxhY2VtZW50czp7Y29uZmlndXJhYmxlOiEwfSxtYXhDb2xvcnM6e2NvbmZpZ3VyYWJsZTohMH0sZXBzaWxvbjp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIHIucmVwbGFjZW1lbnRzLnNldD1mdW5jdGlvbihlKXt2YXIgbj10aGlzLnVuaWZvcm1zLm9yaWdpbmFsQ29sb3JzLHI9dGhpcy51bmlmb3Jtcy50YXJnZXRDb2xvcnMsbz1lLmxlbmd0aDtpZihvPnRoaXMuX21heENvbG9ycyl0aHJvd1wiTGVuZ3RoIG9mIHJlcGxhY2VtZW50cyAoXCIrbytcIikgZXhjZWVkcyB0aGUgbWF4aW11bSBjb2xvcnMgbGVuZ3RoIChcIit0aGlzLl9tYXhDb2xvcnMrXCIpXCI7blszKm9dPS0xO2Zvcih2YXIgaT0wO2k8bztpKyspe3ZhciBsPWVbaV0scz1sWzBdO1wibnVtYmVyXCI9PXR5cGVvZiBzP3M9dC51dGlscy5oZXgycmdiKHMpOmxbMF09dC51dGlscy5yZ2IyaGV4KHMpLG5bMyppXT1zWzBdLG5bMyppKzFdPXNbMV0sblszKmkrMl09c1syXTt2YXIgYT1sWzFdO1wibnVtYmVyXCI9PXR5cGVvZiBhP2E9dC51dGlscy5oZXgycmdiKGEpOmxbMV09dC51dGlscy5yZ2IyaGV4KGEpLHJbMyppXT1hWzBdLHJbMyppKzFdPWFbMV0sclszKmkrMl09YVsyXX10aGlzLl9yZXBsYWNlbWVudHM9ZX0sci5yZXBsYWNlbWVudHMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlcGxhY2VtZW50c30sbi5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3RoaXMucmVwbGFjZW1lbnRzPXRoaXMuX3JlcGxhY2VtZW50c30sci5tYXhDb2xvcnMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21heENvbG9yc30sci5lcHNpbG9uLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmVwc2lsb249ZX0sci5lcHNpbG9uLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmVwc2lsb259LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG4ucHJvdG90eXBlLHIpLG59KHQuRmlsdGVyKSxkZT1uLG1lPVwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxudW5pZm9ybSB2ZWMyIGRpbWVuc2lvbnM7XFxuXFxudW5pZm9ybSBmbG9hdCBzZXBpYTtcXG51bmlmb3JtIGZsb2F0IG5vaXNlO1xcbnVuaWZvcm0gZmxvYXQgbm9pc2VTaXplO1xcbnVuaWZvcm0gZmxvYXQgc2NyYXRjaDtcXG51bmlmb3JtIGZsb2F0IHNjcmF0Y2hEZW5zaXR5O1xcbnVuaWZvcm0gZmxvYXQgc2NyYXRjaFdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgdmlnbmV0dGluZztcXG51bmlmb3JtIGZsb2F0IHZpZ25ldHRpbmdBbHBoYTtcXG51bmlmb3JtIGZsb2F0IHZpZ25ldHRpbmdCbHVyO1xcbnVuaWZvcm0gZmxvYXQgc2VlZDtcXG5cXG5jb25zdCBmbG9hdCBTUVJUXzIgPSAxLjQxNDIxMztcXG5jb25zdCB2ZWMzIFNFUElBX1JHQiA9IHZlYzMoMTEyLjAgLyAyNTUuMCwgNjYuMCAvIDI1NS4wLCAyMC4wIC8gMjU1LjApO1xcblxcbmZsb2F0IHJhbmQodmVjMiBjbykge1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxuXFxudmVjMyBPdmVybGF5KHZlYzMgc3JjLCB2ZWMzIGRzdClcXG57XFxuICAgIC8vIGlmIChkc3QgPD0gMC41KSB0aGVuOiAyICogc3JjICogZHN0XFxuICAgIC8vIGlmIChkc3QgPiAwLjUpIHRoZW46IDEgLSAyICogKDEgLSBkc3QpICogKDEgLSBzcmMpXFxuICAgIHJldHVybiB2ZWMzKChkc3QueCA8PSAwLjUpID8gKDIuMCAqIHNyYy54ICogZHN0LngpIDogKDEuMCAtIDIuMCAqICgxLjAgLSBkc3QueCkgKiAoMS4wIC0gc3JjLngpKSxcXG4gICAgICAgICAgICAgICAgKGRzdC55IDw9IDAuNSkgPyAoMi4wICogc3JjLnkgKiBkc3QueSkgOiAoMS4wIC0gMi4wICogKDEuMCAtIGRzdC55KSAqICgxLjAgLSBzcmMueSkpLFxcbiAgICAgICAgICAgICAgICAoZHN0LnogPD0gMC41KSA/ICgyLjAgKiBzcmMueiAqIGRzdC56KSA6ICgxLjAgLSAyLjAgKiAoMS4wIC0gZHN0LnopICogKDEuMCAtIHNyYy56KSkpO1xcbn1cXG5cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgdmVjMyBjb2xvciA9IGdsX0ZyYWdDb2xvci5yZ2I7XFxuXFxuICAgIGlmIChzZXBpYSA+IDAuMClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgZ3JheSA9IChjb2xvci54ICsgY29sb3IueSArIGNvbG9yLnopIC8gMy4wO1xcbiAgICAgICAgdmVjMyBncmF5c2NhbGUgPSB2ZWMzKGdyYXkpO1xcblxcbiAgICAgICAgY29sb3IgPSBPdmVybGF5KFNFUElBX1JHQiwgZ3JheXNjYWxlKTtcXG5cXG4gICAgICAgIGNvbG9yID0gZ3JheXNjYWxlICsgc2VwaWEgKiAoY29sb3IgLSBncmF5c2NhbGUpO1xcbiAgICB9XFxuXFxuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkICogZmlsdGVyQXJlYS54eSAvIGRpbWVuc2lvbnMueHk7XFxuXFxuICAgIGlmICh2aWduZXR0aW5nID4gMC4wKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCBvdXR0ZXIgPSBTUVJUXzIgLSB2aWduZXR0aW5nICogU1FSVF8yO1xcbiAgICAgICAgdmVjMiBkaXIgPSB2ZWMyKHZlYzIoMC41LCAwLjUpIC0gY29vcmQpO1xcbiAgICAgICAgZGlyLnkgKj0gZGltZW5zaW9ucy55IC8gZGltZW5zaW9ucy54O1xcbiAgICAgICAgZmxvYXQgZGFya2VyID0gY2xhbXAoKG91dHRlciAtIGxlbmd0aChkaXIpICogU1FSVF8yKSAvICggMC4wMDAwMSArIHZpZ25ldHRpbmdCbHVyICogU1FSVF8yKSwgMC4wLCAxLjApO1xcbiAgICAgICAgY29sb3IucmdiICo9IGRhcmtlciArICgxLjAgLSBkYXJrZXIpICogKDEuMCAtIHZpZ25ldHRpbmdBbHBoYSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNjcmF0Y2hEZW5zaXR5ID4gc2VlZCAmJiBzY3JhdGNoICE9IDAuMClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgcGhhc2UgPSBzZWVkICogMjU2LjA7XFxuICAgICAgICBmbG9hdCBzID0gbW9kKGZsb29yKHBoYXNlKSwgMi4wKTtcXG4gICAgICAgIGZsb2F0IGRpc3QgPSAxLjAgLyBzY3JhdGNoRGVuc2l0eTtcXG4gICAgICAgIGZsb2F0IGQgPSBkaXN0YW5jZShjb29yZCwgdmVjMihzZWVkICogZGlzdCwgYWJzKHMgLSBzZWVkICogZGlzdCkpKTtcXG4gICAgICAgIGlmIChkIDwgc2VlZCAqIDAuNiArIDAuNClcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBoaWdocCBmbG9hdCBwZXJpb2QgPSBzY3JhdGNoRGVuc2l0eSAqIDEwLjA7XFxuXFxuICAgICAgICAgICAgZmxvYXQgeHggPSBjb29yZC54ICogcGVyaW9kICsgcGhhc2U7XFxuICAgICAgICAgICAgZmxvYXQgYWEgPSBhYnMobW9kKHh4LCAwLjUpICogNC4wKTtcXG4gICAgICAgICAgICBmbG9hdCBiYiA9IG1vZChmbG9vcih4eCAvIDAuNSksIDIuMCk7XFxuICAgICAgICAgICAgZmxvYXQgeXkgPSAoMS4wIC0gYmIpICogYWEgKyBiYiAqICgyLjAgLSBhYSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQga2sgPSAyLjAgKiBwZXJpb2Q7XFxuICAgICAgICAgICAgZmxvYXQgZHcgPSBzY3JhdGNoV2lkdGggLyBkaW1lbnNpb25zLnggKiAoMC43NSArIHNlZWQpO1xcbiAgICAgICAgICAgIGZsb2F0IGRoID0gZHcgKiBraztcXG5cXG4gICAgICAgICAgICBmbG9hdCB0aW5lID0gKHl5IC0gKDIuMCAtIGRoKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHRpbmUgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgX3NpZ24gPSBzaWduKHNjcmF0Y2gpO1xcblxcbiAgICAgICAgICAgICAgICB0aW5lID0gcyAqIHRpbmUgLyBwZXJpb2QgKyBzY3JhdGNoICsgMC4xO1xcbiAgICAgICAgICAgICAgICB0aW5lID0gY2xhbXAodGluZSArIDEuMCwgMC41ICsgX3NpZ24gKiAwLjUsIDEuNSArIF9zaWduICogMC41KTtcXG5cXG4gICAgICAgICAgICAgICAgY29sb3IucmdiICo9IHRpbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChub2lzZSA+IDAuMCAmJiBub2lzZVNpemUgPiAwLjApXFxuICAgIHtcXG4gICAgICAgIHZlYzIgcGl4ZWxDb29yZCA9IHZUZXh0dXJlQ29vcmQueHkgKiBmaWx0ZXJBcmVhLnh5O1xcbiAgICAgICAgcGl4ZWxDb29yZC54ID0gZmxvb3IocGl4ZWxDb29yZC54IC8gbm9pc2VTaXplKTtcXG4gICAgICAgIHBpeGVsQ29vcmQueSA9IGZsb29yKHBpeGVsQ29vcmQueSAvIG5vaXNlU2l6ZSk7XFxuICAgICAgICAvLyB2ZWMyIGQgPSBwaXhlbENvb3JkICogbm9pc2VTaXplICogdmVjMigxMDI0LjAgKyBzZWVkICogNTEyLjAsIDEwMjQuMCAtIHNlZWQgKiA1MTIuMCk7XFxuICAgICAgICAvLyBmbG9hdCBfbm9pc2UgPSBzbm9pc2UoZCkgKiAwLjU7XFxuICAgICAgICBmbG9hdCBfbm9pc2UgPSByYW5kKHBpeGVsQ29vcmQgKiBub2lzZVNpemUgKiBzZWVkKSAtIDAuNTtcXG4gICAgICAgIGNvbG9yICs9IF9ub2lzZSAqIG5vaXNlO1xcbiAgICB9XFxuXFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBjb2xvcjtcXG59XFxuXCIsZ2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4pe3ZvaWQgMD09PW4mJihuPTApLGUuY2FsbCh0aGlzLGRlLG1lKSx0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnM9bmV3IEZsb2F0MzJBcnJheSgyKSxcIm51bWJlclwiPT10eXBlb2YgdD8odGhpcy5zZWVkPXQsdD1udWxsKTp0aGlzLnNlZWQ9bixPYmplY3QuYXNzaWduKHRoaXMse3NlcGlhOi4zLG5vaXNlOi4zLG5vaXNlU2l6ZToxLHNjcmF0Y2g6LjUsc2NyYXRjaERlbnNpdHk6LjMsc2NyYXRjaFdpZHRoOjEsdmlnbmV0dGluZzouMyx2aWduZXR0aW5nQWxwaGE6MSx2aWduZXR0aW5nQmx1cjouM30sdCl9ZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQ7dmFyIG49e3NlcGlhOntjb25maWd1cmFibGU6ITB9LG5vaXNlOntjb25maWd1cmFibGU6ITB9LG5vaXNlU2l6ZTp7Y29uZmlndXJhYmxlOiEwfSxzY3JhdGNoOntjb25maWd1cmFibGU6ITB9LHNjcmF0Y2hEZW5zaXR5Ontjb25maWd1cmFibGU6ITB9LHNjcmF0Y2hXaWR0aDp7Y29uZmlndXJhYmxlOiEwfSx2aWduZXR0aW5nOntjb25maWd1cmFibGU6ITB9LHZpZ25ldHRpbmdBbHBoYTp7Y29uZmlndXJhYmxlOiEwfSx2aWduZXR0aW5nQmx1cjp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3RoaXMudW5pZm9ybXMuZGltZW5zaW9uc1swXT10LnNvdXJjZUZyYW1lLndpZHRoLHRoaXMudW5pZm9ybXMuZGltZW5zaW9uc1sxXT10LnNvdXJjZUZyYW1lLmhlaWdodCx0aGlzLnVuaWZvcm1zLnNlZWQ9dGhpcy5zZWVkLGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4scil9LG4uc2VwaWEuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuc2VwaWE9ZX0sbi5zZXBpYS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5zZXBpYX0sbi5ub2lzZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5ub2lzZT1lfSxuLm5vaXNlLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLm5vaXNlfSxuLm5vaXNlU2l6ZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5ub2lzZVNpemU9ZX0sbi5ub2lzZVNpemUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMubm9pc2VTaXplfSxuLnNjcmF0Y2guc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuc2NyYXRjaD1lfSxuLnNjcmF0Y2guZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuc2NyYXRjaH0sbi5zY3JhdGNoRGVuc2l0eS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5zY3JhdGNoRGVuc2l0eT1lfSxuLnNjcmF0Y2hEZW5zaXR5LmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnNjcmF0Y2hEZW5zaXR5fSxuLnNjcmF0Y2hXaWR0aC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5zY3JhdGNoV2lkdGg9ZX0sbi5zY3JhdGNoV2lkdGguZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuc2NyYXRjaFdpZHRofSxuLnZpZ25ldHRpbmcuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMudmlnbmV0dGluZz1lfSxuLnZpZ25ldHRpbmcuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudmlnbmV0dGluZ30sbi52aWduZXR0aW5nQWxwaGEuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMudmlnbmV0dGluZ0FscGhhPWV9LG4udmlnbmV0dGluZ0FscGhhLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnZpZ25ldHRpbmdBbHBoYX0sbi52aWduZXR0aW5nQmx1ci5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy52aWduZXR0aW5nQmx1cj1lfSxuLnZpZ25ldHRpbmdCbHVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnZpZ25ldHRpbmdCbHVyfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksdmU9bix4ZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnVuaWZvcm0gdmVjMiB0aGlja25lc3M7XFxudW5pZm9ybSB2ZWM0IG91dGxpbmVDb2xvcjtcXG51bmlmb3JtIHZlYzQgZmlsdGVyQ2xhbXA7XFxuXFxuY29uc3QgZmxvYXQgRE9VQkxFX1BJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NCAqIDIuO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzQgb3duQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWM0IGN1ckNvbG9yO1xcbiAgICBmbG9hdCBtYXhBbHBoYSA9IDAuO1xcbiAgICB2ZWMyIGRpc3BsYWNlZDtcXG4gICAgZm9yIChmbG9hdCBhbmdsZSA9IDAuOyBhbmdsZSA8PSBET1VCTEVfUEk7IGFuZ2xlICs9ICR7YW5nbGVTdGVwfSkge1xcbiAgICAgICAgZGlzcGxhY2VkLnggPSB2VGV4dHVyZUNvb3JkLnggKyB0aGlja25lc3MueCAqIGNvcyhhbmdsZSk7XFxuICAgICAgICBkaXNwbGFjZWQueSA9IHZUZXh0dXJlQ29vcmQueSArIHRoaWNrbmVzcy55ICogc2luKGFuZ2xlKTtcXG4gICAgICAgIGN1ckNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjbGFtcChkaXNwbGFjZWQsIGZpbHRlckNsYW1wLnh5LCBmaWx0ZXJDbGFtcC56dykpO1xcbiAgICAgICAgbWF4QWxwaGEgPSBtYXgobWF4QWxwaGEsIGN1ckNvbG9yLmEpO1xcbiAgICB9XFxuICAgIGZsb2F0IHJlc3VsdEFscGhhID0gbWF4KG1heEFscGhhLCBvd25Db2xvci5hKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgob3duQ29sb3IucmdiICsgb3V0bGluZUNvbG9yLnJnYiAqICgxLiAtIG93bkNvbG9yLmEpKSAqIHJlc3VsdEFscGhhLCByZXN1bHRBbHBoYSk7XFxufVxcblwiLHllPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxyLG8pe3ZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPS4xKTt2YXIgaT1NYXRoLm1heChvKm4uTUFYX1NBTVBMRVMsbi5NSU5fU0FNUExFUyksbD0oMipNYXRoLlBJL2kpLnRvRml4ZWQoNyk7ZS5jYWxsKHRoaXMsdmUseGUucmVwbGFjZSgvXFwkXFx7YW5nbGVTdGVwXFx9LyxsKSksdGhpcy51bmlmb3Jtcy50aGlja25lc3M9bmV3IEZsb2F0MzJBcnJheShbMCwwXSksdGhpcy50aGlja25lc3M9dCx0aGlzLnVuaWZvcm1zLm91dGxpbmVDb2xvcj1uZXcgRmxvYXQzMkFycmF5KFswLDAsMCwxXSksdGhpcy5jb2xvcj1yLHRoaXMucXVhbGl0eT1vfWUmJihuLl9fcHJvdG9fXz1lKSxuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSxuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1uO3ZhciByPXtjb2xvcjp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3RoaXMudW5pZm9ybXMudGhpY2tuZXNzWzBdPXRoaXMudGhpY2tuZXNzL3Quc2l6ZS53aWR0aCx0aGlzLnVuaWZvcm1zLnRoaWNrbmVzc1sxXT10aGlzLnRoaWNrbmVzcy90LnNpemUuaGVpZ2h0LGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4scil9LHIuY29sb3IuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHQudXRpbHMucmdiMmhleCh0aGlzLnVuaWZvcm1zLm91dGxpbmVDb2xvcil9LHIuY29sb3Iuc2V0PWZ1bmN0aW9uKGUpe3QudXRpbHMuaGV4MnJnYihlLHRoaXMudW5pZm9ybXMub3V0bGluZUNvbG9yKX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobi5wcm90b3R5cGUsciksbn0odC5GaWx0ZXIpO3llLk1JTl9TQU1QTEVTPTEseWUuTUFYX1NBTVBMRVM9MTAwO3ZhciBiZT1uLF9lPVwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWMyIHNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxuXFxudmVjMiBtYXBDb29yZCggdmVjMiBjb29yZCApXFxue1xcbiAgICBjb29yZCAqPSBmaWx0ZXJBcmVhLnh5O1xcbiAgICBjb29yZCArPSBmaWx0ZXJBcmVhLnp3O1xcblxcbiAgICByZXR1cm4gY29vcmQ7XFxufVxcblxcbnZlYzIgdW5tYXBDb29yZCggdmVjMiBjb29yZCApXFxue1xcbiAgICBjb29yZCAtPSBmaWx0ZXJBcmVhLnp3O1xcbiAgICBjb29yZCAvPSBmaWx0ZXJBcmVhLnh5O1xcblxcbiAgICByZXR1cm4gY29vcmQ7XFxufVxcblxcbnZlYzIgcGl4ZWxhdGUodmVjMiBjb29yZCwgdmVjMiBzaXplKVxcbntcXG5cXHRyZXR1cm4gZmxvb3IoIGNvb3JkIC8gc2l6ZSApICogc2l6ZTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWMyIGNvb3JkID0gbWFwQ29vcmQodlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGNvb3JkID0gcGl4ZWxhdGUoY29vcmQsIHNpemUpO1xcblxcbiAgICBjb29yZCA9IHVubWFwQ29vcmQoY29vcmQpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKTtcXG59XFxuXCIsQ2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2b2lkIDA9PT10JiYodD0xMCksZS5jYWxsKHRoaXMsYmUsX2UpLHRoaXMuc2l6ZT10fWUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10O3ZhciBuPXtzaXplOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5zaXplLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnNpemV9LG4uc2l6ZS5zZXQ9ZnVuY3Rpb24oZSl7XCJudW1iZXJcIj09dHlwZW9mIGUmJihlPVtlLGVdKSx0aGlzLnVuaWZvcm1zLnNpemU9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLFNlPW4sRmU9XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG5cXG51bmlmb3JtIGZsb2F0IHVSYWRpYW47XFxudW5pZm9ybSB2ZWMyIHVDZW50ZXI7XFxudW5pZm9ybSBmbG9hdCB1UmFkaXVzO1xcbnVuaWZvcm0gaW50IHVLZXJuZWxTaXplO1xcblxcbmNvbnN0IGludCBNQVhfS0VSTkVMX1NJWkUgPSAyMDQ4O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGlmICh1S2VybmVsU2l6ZSA9PSAwKVxcbiAgICB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBhc3BlY3QgPSBmaWx0ZXJBcmVhLnkgLyBmaWx0ZXJBcmVhLng7XFxuICAgIHZlYzIgY2VudGVyID0gdUNlbnRlci54eSAvIGZpbHRlckFyZWEueHk7XFxuICAgIGZsb2F0IGdyYWRpZW50ID0gdVJhZGl1cyAvIGZpbHRlckFyZWEueCAqIDAuMztcXG4gICAgZmxvYXQgcmFkaXVzID0gdVJhZGl1cyAvIGZpbHRlckFyZWEueCAtIGdyYWRpZW50ICogMC41O1xcbiAgICBpbnQgayA9IHVLZXJuZWxTaXplIC0gMTtcXG5cXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQ7XFxuICAgIHZlYzIgZGlyID0gdmVjMihjZW50ZXIgLSBjb29yZCk7XFxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodmVjMihkaXIueCwgZGlyLnkgKiBhc3BlY3QpKTtcXG5cXG4gICAgZmxvYXQgcmFkaWFuU3RlcCA9IHVSYWRpYW47XFxuICAgIGlmIChyYWRpdXMgPj0gMC4wICYmIGRpc3QgPiByYWRpdXMpIHtcXG4gICAgICAgIGZsb2F0IGRlbHRhID0gZGlzdCAtIHJhZGl1cztcXG4gICAgICAgIGZsb2F0IGdhcCA9IGdyYWRpZW50O1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSAxLjAgLSBhYnMoZGVsdGEgLyBnYXApO1xcbiAgICAgICAgaWYgKHNjYWxlIDw9IDAuMCkge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJhZGlhblN0ZXAgKj0gc2NhbGU7XFxuICAgIH1cXG4gICAgcmFkaWFuU3RlcCAvPSBmbG9hdChrKTtcXG5cXG4gICAgZmxvYXQgcyA9IHNpbihyYWRpYW5TdGVwKTtcXG4gICAgZmxvYXQgYyA9IGNvcyhyYWRpYW5TdGVwKTtcXG4gICAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIodmVjMihjLCAtcyksIHZlYzIocywgYykpO1xcblxcbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgTUFYX0tFUk5FTF9TSVpFIC0gMTsgaSsrKSB7XFxuICAgICAgICBpZiAoaSA9PSBrKSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb29yZCAtPSBjZW50ZXI7XFxuICAgICAgICBjb29yZC55ICo9IGFzcGVjdDtcXG4gICAgICAgIGNvb3JkID0gcm90YXRpb25NYXRyaXggKiBjb29yZDtcXG4gICAgICAgIGNvb3JkLnkgLz0gYXNwZWN0O1xcbiAgICAgICAgY29vcmQgKz0gY2VudGVyO1xcblxcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKTtcXG5cXG4gICAgICAgIC8vIHN3aXRjaCB0byBwcmUtbXVsdGlwbGllZCBhbHBoYSB0byBjb3JyZWN0bHkgYmx1ciB0cmFuc3BhcmVudCBpbWFnZXNcXG4gICAgICAgIC8vIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxuXFxuICAgICAgICBjb2xvciArPSBzYW1wbGU7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyBmbG9hdCh1S2VybmVsU2l6ZSk7XFxufVxcblwiLHplPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuLHIsbyl7dm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49WzAsMF0pLHZvaWQgMD09PXImJihyPTUpLHZvaWQgMD09PW8mJihvPS0xKSxlLmNhbGwodGhpcyxTZSxGZSksdGhpcy5fYW5nbGU9MCx0aGlzLmFuZ2xlPXQsdGhpcy5jZW50ZXI9bix0aGlzLmtlcm5lbFNpemU9cix0aGlzLnJhZGl1cz1vfWUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10O3ZhciBuPXthbmdsZTp7Y29uZmlndXJhYmxlOiEwfSxjZW50ZXI6e2NvbmZpZ3VyYWJsZTohMH0scmFkaXVzOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0LG4scil7dGhpcy51bmlmb3Jtcy51S2VybmVsU2l6ZT0wIT09dGhpcy5fYW5nbGU/dGhpcy5rZXJuZWxTaXplOjAsZS5hcHBseUZpbHRlcih0aGlzLHQsbixyKX0sbi5hbmdsZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy5fYW5nbGU9ZSx0aGlzLnVuaWZvcm1zLnVSYWRpYW49ZSpNYXRoLlBJLzE4MH0sbi5hbmdsZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYW5nbGV9LG4uY2VudGVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnVDZW50ZXJ9LG4uY2VudGVyLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnVDZW50ZXI9ZX0sbi5yYWRpdXMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudVJhZGl1c30sbi5yYWRpdXMuc2V0PWZ1bmN0aW9uKGUpeyhlPDB8fGU9PT0xLzApJiYoZT0tMSksdGhpcy51bmlmb3Jtcy51UmFkaXVzPWV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQucHJvdG90eXBlLG4pLHR9KHQuRmlsdGVyKSxBZT1uLHdlPVwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckNsYW1wO1xcbnVuaWZvcm0gdmVjMiBkaW1lbnNpb25zO1xcblxcbnVuaWZvcm0gYm9vbCBtaXJyb3I7XFxudW5pZm9ybSBmbG9hdCBib3VuZGFyeTtcXG51bmlmb3JtIHZlYzIgYW1wbGl0dWRlO1xcbnVuaWZvcm0gdmVjMiB3YXZlTGVuZ3RoO1xcbnVuaWZvcm0gdmVjMiBhbHBoYTtcXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuXFxuZmxvYXQgcmFuZCh2ZWMyIGNvKSB7XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzIgcGl4ZWxDb29yZCA9IHZUZXh0dXJlQ29vcmQueHkgKiBmaWx0ZXJBcmVhLnh5O1xcbiAgICB2ZWMyIGNvb3JkID0gcGl4ZWxDb29yZCAvIGRpbWVuc2lvbnM7XFxuXFxuICAgIGlmIChjb29yZC55IDwgYm91bmRhcnkpIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgayA9IChjb29yZC55IC0gYm91bmRhcnkpIC8gKDEuIC0gYm91bmRhcnkgKyAwLjAwMDEpO1xcbiAgICBmbG9hdCBhcmVhWSA9IGJvdW5kYXJ5ICogZGltZW5zaW9ucy55IC8gZmlsdGVyQXJlYS55O1xcbiAgICBmbG9hdCB2ID0gYXJlYVkgKyBhcmVhWSAtIHZUZXh0dXJlQ29vcmQueTtcXG4gICAgZmxvYXQgeSA9IG1pcnJvciA/IHYgOiB2VGV4dHVyZUNvb3JkLnk7XFxuXFxuICAgIGZsb2F0IF9hbXBsaXR1ZGUgPSAoKGFtcGxpdHVkZS55IC0gYW1wbGl0dWRlLngpICogayArIGFtcGxpdHVkZS54ICkgLyBmaWx0ZXJBcmVhLng7XFxuICAgIGZsb2F0IF93YXZlTGVuZ3RoID0gKCh3YXZlTGVuZ3RoLnkgLSB3YXZlTGVuZ3RoLngpICogayArIHdhdmVMZW5ndGgueCkgLyBmaWx0ZXJBcmVhLnk7XFxuICAgIGZsb2F0IF9hbHBoYSA9IChhbHBoYS55IC0gYWxwaGEueCkgKiBrICsgYWxwaGEueDtcXG5cXG4gICAgZmxvYXQgeCA9IHZUZXh0dXJlQ29vcmQueCArIGNvcyh2ICogNi4yOCAvIF93YXZlTGVuZ3RoIC0gdGltZSkgKiBfYW1wbGl0dWRlO1xcbiAgICB4ID0gY2xhbXAoeCwgZmlsdGVyQ2xhbXAueCwgZmlsdGVyQ2xhbXAueik7XFxuXFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZlYzIoeCwgeSkpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIF9hbHBoYTtcXG59XFxuXCIsVGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtlLmNhbGwodGhpcyxBZSx3ZSksdGhpcy51bmlmb3Jtcy5hbXBsaXR1ZGU9bmV3IEZsb2F0MzJBcnJheSgyKSx0aGlzLnVuaWZvcm1zLndhdmVMZW5ndGg9bmV3IEZsb2F0MzJBcnJheSgyKSx0aGlzLnVuaWZvcm1zLmFscGhhPW5ldyBGbG9hdDMyQXJyYXkoMiksdGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zPW5ldyBGbG9hdDMyQXJyYXkoMiksT2JqZWN0LmFzc2lnbih0aGlzLHttaXJyb3I6ITAsYm91bmRhcnk6LjUsYW1wbGl0dWRlOlswLDIwXSx3YXZlTGVuZ3RoOlszMCwxMDBdLGFscGhhOlsxLDFdLHRpbWU6MH0sdCl9ZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQ7dmFyIG49e21pcnJvcjp7Y29uZmlndXJhYmxlOiEwfSxib3VuZGFyeTp7Y29uZmlndXJhYmxlOiEwfSxhbXBsaXR1ZGU6e2NvbmZpZ3VyYWJsZTohMH0sd2F2ZUxlbmd0aDp7Y29uZmlndXJhYmxlOiEwfSxhbHBoYTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCxuLHIpe3RoaXMudW5pZm9ybXMuZGltZW5zaW9uc1swXT10LnNvdXJjZUZyYW1lLndpZHRoLHRoaXMudW5pZm9ybXMuZGltZW5zaW9uc1sxXT10LnNvdXJjZUZyYW1lLmhlaWdodCx0aGlzLnVuaWZvcm1zLnRpbWU9dGhpcy50aW1lLGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4scil9LG4ubWlycm9yLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLm1pcnJvcj1lfSxuLm1pcnJvci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5taXJyb3J9LG4uYm91bmRhcnkuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuYm91bmRhcnk9ZX0sbi5ib3VuZGFyeS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5ib3VuZGFyeX0sbi5hbXBsaXR1ZGUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuYW1wbGl0dWRlWzBdPWVbMF0sdGhpcy51bmlmb3Jtcy5hbXBsaXR1ZGVbMV09ZVsxXX0sbi5hbXBsaXR1ZGUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuYW1wbGl0dWRlfSxuLndhdmVMZW5ndGguc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMud2F2ZUxlbmd0aFswXT1lWzBdLHRoaXMudW5pZm9ybXMud2F2ZUxlbmd0aFsxXT1lWzFdfSxuLndhdmVMZW5ndGguZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMud2F2ZUxlbmd0aH0sbi5hbHBoYS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5hbHBoYVswXT1lWzBdLHRoaXMudW5pZm9ybXMuYWxwaGFbMV09ZVsxXX0sbi5hbHBoYS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5hbHBoYX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLERlPW4sT2U9XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG51bmlmb3JtIHZlYzIgcmVkO1xcbnVuaWZvcm0gdmVjMiBncmVlbjtcXG51bmlmb3JtIHZlYzIgYmx1ZTtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgZ2xfRnJhZ0NvbG9yLnIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyByZWQvZmlsdGVyQXJlYS54eSkucjtcXG4gICBnbF9GcmFnQ29sb3IuZyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCArIGdyZWVuL2ZpbHRlckFyZWEueHkpLmc7XFxuICAgZ2xfRnJhZ0NvbG9yLmIgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBibHVlL2ZpbHRlckFyZWEueHkpLmI7XFxuICAgZ2xfRnJhZ0NvbG9yLmEgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpLmE7XFxufVxcblwiLFBlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuLHIpe3ZvaWQgMD09PXQmJih0PVstMTAsMF0pLHZvaWQgMD09PW4mJihuPVswLDEwXSksdm9pZCAwPT09ciYmKHI9WzAsMF0pLGUuY2FsbCh0aGlzLERlLE9lKSx0aGlzLnJlZD10LHRoaXMuZ3JlZW49bix0aGlzLmJsdWU9cn1lJiYodC5fX3Byb3RvX189ZSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dDt2YXIgbj17cmVkOntjb25maWd1cmFibGU6ITB9LGdyZWVuOntjb25maWd1cmFibGU6ITB9LGJsdWU6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiBuLnJlZC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5yZWR9LG4ucmVkLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnJlZD1lfSxuLmdyZWVuLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmdyZWVufSxuLmdyZWVuLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmdyZWVuPWV9LG4uYmx1ZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVlfSxuLmJsdWUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuYmx1ZT1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksTWU9bixSZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCBmaWx0ZXJBcmVhO1xcbnVuaWZvcm0gdmVjNCBmaWx0ZXJDbGFtcDtcXG5cXG51bmlmb3JtIHZlYzIgY2VudGVyO1xcblxcbnVuaWZvcm0gZmxvYXQgYW1wbGl0dWRlO1xcbnVuaWZvcm0gZmxvYXQgd2F2ZWxlbmd0aDtcXG4vLyB1bmlmb3JtIGZsb2F0IHBvd2VyO1xcbnVuaWZvcm0gZmxvYXQgYnJpZ2h0bmVzcztcXG51bmlmb3JtIGZsb2F0IHNwZWVkO1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xcblxcbnVuaWZvcm0gZmxvYXQgdGltZTtcXG5cXG5jb25zdCBmbG9hdCBQSSA9IDMuMTQxNTk7XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAgIGZsb2F0IGhhbGZXYXZlbGVuZ3RoID0gd2F2ZWxlbmd0aCAqIDAuNSAvIGZpbHRlckFyZWEueDtcXG4gICAgZmxvYXQgbWF4UmFkaXVzID0gcmFkaXVzIC8gZmlsdGVyQXJlYS54O1xcbiAgICBmbG9hdCBjdXJyZW50UmFkaXVzID0gdGltZSAqIHNwZWVkIC8gZmlsdGVyQXJlYS54O1xcblxcbiAgICBmbG9hdCBmYWRlID0gMS4wO1xcblxcbiAgICBpZiAobWF4UmFkaXVzID4gMC4wKSB7XFxuICAgICAgICBpZiAoY3VycmVudFJhZGl1cyA+IG1heFJhZGl1cykge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmFkZSA9IDEuMCAtIHBvdyhjdXJyZW50UmFkaXVzIC8gbWF4UmFkaXVzLCAyLjApO1xcbiAgICB9XFxuXFxuICAgIHZlYzIgZGlyID0gdmVjMih2VGV4dHVyZUNvb3JkIC0gY2VudGVyIC8gZmlsdGVyQXJlYS54eSk7XFxuICAgIGRpci55ICo9IGZpbHRlckFyZWEueSAvIGZpbHRlckFyZWEueDtcXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aChkaXIpO1xcblxcbiAgICBpZiAoZGlzdCA8PSAwLjAgfHwgZGlzdCA8IGN1cnJlbnRSYWRpdXMgLSBoYWxmV2F2ZWxlbmd0aCB8fCBkaXN0ID4gY3VycmVudFJhZGl1cyArIGhhbGZXYXZlbGVuZ3RoKSB7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZlYzIgZGlmZlVWID0gbm9ybWFsaXplKGRpcik7XFxuXFxuICAgIGZsb2F0IGRpZmYgPSAoZGlzdCAtIGN1cnJlbnRSYWRpdXMpIC8gaGFsZldhdmVsZW5ndGg7XFxuXFxuICAgIGZsb2F0IHAgPSAxLjAgLSBwb3coYWJzKGRpZmYpLCAyLjApO1xcblxcbiAgICAvLyBmbG9hdCBwb3dEaWZmID0gZGlmZiAqIHBvdyhwLCAyLjApICogKCBhbXBsaXR1ZGUgKiBmYWRlICk7XFxuICAgIGZsb2F0IHBvd0RpZmYgPSAxLjI1ICogc2luKGRpZmYgKiBQSSkgKiBwICogKCBhbXBsaXR1ZGUgKiBmYWRlICk7XFxuXFxuICAgIHZlYzIgb2Zmc2V0ID0gZGlmZlVWICogcG93RGlmZiAvIGZpbHRlckFyZWEueHk7XFxuXFxuICAgIC8vIERvIGNsYW1wIDpcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBvZmZzZXQ7XFxuICAgIHZlYzIgY2xhbXBlZENvb3JkID0gY2xhbXAoY29vcmQsIGZpbHRlckNsYW1wLnh5LCBmaWx0ZXJDbGFtcC56dyk7XFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNsYW1wZWRDb29yZCk7XFxuICAgIGlmIChjb29yZCAhPSBjbGFtcGVkQ29vcmQpIHtcXG4gICAgICAgIGNvbG9yICo9IG1heCgwLjAsIDEuMCAtIGxlbmd0aChjb29yZCAtIGNsYW1wZWRDb29yZCkpO1xcbiAgICB9XFxuXFxuICAgIC8vIE5vIGNsYW1wIDpcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkICsgb2Zmc2V0KTtcXG5cXG4gICAgY29sb3IucmdiICo9IDEuMCArIChicmlnaHRuZXNzIC0gMS4wKSAqIHAgKiBmYWRlO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCIsamU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4scil7dm9pZCAwPT09dCYmKHQ9WzAsMF0pLHZvaWQgMD09PW4mJihuPXt9KSx2b2lkIDA9PT1yJiYocj0wKSxlLmNhbGwodGhpcyxNZSxSZSksdGhpcy5jZW50ZXI9dCxBcnJheS5pc0FycmF5KG4pJiYoY29uc29sZS53YXJuKFwiRGVwcmVjYXRlZCBXYXJuaW5nOiBTaG9ja3dhdmVGaWx0ZXIgcGFyYW1zIEFycmF5IGhhcyBiZWVuIGNoYW5nZWQgdG8gb3B0aW9ucyBPYmplY3QuXCIpLG49e30pLG49T2JqZWN0LmFzc2lnbih7YW1wbGl0dWRlOjMwLHdhdmVsZW5ndGg6MTYwLGJyaWdodG5lc3M6MSxzcGVlZDo1MDAscmFkaXVzOi0xfSxuKSx0aGlzLmFtcGxpdHVkZT1uLmFtcGxpdHVkZSx0aGlzLndhdmVsZW5ndGg9bi53YXZlbGVuZ3RoLHRoaXMuYnJpZ2h0bmVzcz1uLmJyaWdodG5lc3MsdGhpcy5zcGVlZD1uLnNwZWVkLHRoaXMucmFkaXVzPW4ucmFkaXVzLHRoaXMudGltZT1yfWUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10O3ZhciBuPXtjZW50ZXI6e2NvbmZpZ3VyYWJsZTohMH0sYW1wbGl0dWRlOntjb25maWd1cmFibGU6ITB9LHdhdmVsZW5ndGg6e2NvbmZpZ3VyYWJsZTohMH0sYnJpZ2h0bmVzczp7Y29uZmlndXJhYmxlOiEwfSxzcGVlZDp7Y29uZmlndXJhYmxlOiEwfSxyYWRpdXM6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiB0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQsbixyKXt0aGlzLnVuaWZvcm1zLnRpbWU9dGhpcy50aW1lLGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4scil9LG4uY2VudGVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmNlbnRlcn0sbi5jZW50ZXIuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuY2VudGVyPWV9LG4uYW1wbGl0dWRlLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLmFtcGxpdHVkZX0sbi5hbXBsaXR1ZGUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuYW1wbGl0dWRlPWV9LG4ud2F2ZWxlbmd0aC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy53YXZlbGVuZ3RofSxuLndhdmVsZW5ndGguc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMud2F2ZWxlbmd0aD1lfSxuLmJyaWdodG5lc3MuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuYnJpZ2h0bmVzc30sbi5icmlnaHRuZXNzLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmJyaWdodG5lc3M9ZX0sbi5zcGVlZC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5zcGVlZH0sbi5zcGVlZC5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy5zcGVlZD1lfSxuLnJhZGl1cy5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5yYWRpdXN9LG4ucmFkaXVzLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnJhZGl1cz1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LnByb3RvdHlwZSxuKSx0fSh0LkZpbHRlciksTGU9bixrZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVMaWdodG1hcDtcXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG51bmlmb3JtIHZlYzIgZGltZW5zaW9ucztcXG51bmlmb3JtIHZlYzQgYW1iaWVudENvbG9yO1xcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBkaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWMyIGxpZ2h0Q29vcmQgPSAodlRleHR1cmVDb29yZCAqIGZpbHRlckFyZWEueHkpIC8gZGltZW5zaW9ucztcXG4gICAgdmVjNCBsaWdodCA9IHRleHR1cmUyRCh1TGlnaHRtYXAsIGxpZ2h0Q29vcmQpO1xcbiAgICB2ZWMzIGFtYmllbnQgPSBhbWJpZW50Q29sb3IucmdiICogYW1iaWVudENvbG9yLmE7XFxuICAgIHZlYzMgaW50ZW5zaXR5ID0gYW1iaWVudCArIGxpZ2h0LnJnYjtcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqIGludGVuc2l0eTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChmaW5hbENvbG9yLCBkaWZmdXNlQ29sb3IuYSk7XFxufVxcblwiLEllPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxuLHIpe3ZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PXImJihyPTEpLGUuY2FsbCh0aGlzLExlLGtlKSx0aGlzLnVuaWZvcm1zLmRpbWVuc2lvbnM9bmV3IEZsb2F0MzJBcnJheSgyKSx0aGlzLnVuaWZvcm1zLmFtYmllbnRDb2xvcj1uZXcgRmxvYXQzMkFycmF5KFswLDAsMCxyXSksdGhpcy50ZXh0dXJlPXQsdGhpcy5jb2xvcj1ufWUmJihuLl9fcHJvdG9fXz1lKSxuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSxuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1uO3ZhciByPXt0ZXh0dXJlOntjb25maWd1cmFibGU6ITB9LGNvbG9yOntjb25maWd1cmFibGU6ITB9LGFscGhhOntjb25maWd1cmFibGU6ITB9fTtyZXR1cm4gbi5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0LG4scil7dGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zWzBdPXQuc291cmNlRnJhbWUud2lkdGgsdGhpcy51bmlmb3Jtcy5kaW1lbnNpb25zWzFdPXQuc291cmNlRnJhbWUuaGVpZ2h0LGUuYXBwbHlGaWx0ZXIodGhpcyx0LG4scil9LHIudGV4dHVyZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy51TGlnaHRtYXB9LHIudGV4dHVyZS5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy51TGlnaHRtYXA9ZX0sci5jb2xvci5zZXQ9ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy51bmlmb3Jtcy5hbWJpZW50Q29sb3I7XCJudW1iZXJcIj09dHlwZW9mIGU/KHQudXRpbHMuaGV4MnJnYihlLG4pLHRoaXMuX2NvbG9yPWUpOihuWzBdPWVbMF0sblsxXT1lWzFdLG5bMl09ZVsyXSxuWzNdPWVbM10sdGhpcy5fY29sb3I9dC51dGlscy5yZ2IyaGV4KG4pKX0sci5jb2xvci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29sb3J9LHIuYWxwaGEuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuYW1iaWVudENvbG9yWzNdfSxyLmFscGhhLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmFtYmllbnRDb2xvclszXT1lfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLnByb3RvdHlwZSxyKSxufSh0LkZpbHRlciksRWU9bixCZT1cInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgYmx1cjtcXG51bmlmb3JtIGZsb2F0IGdyYWRpZW50Qmx1cjtcXG51bmlmb3JtIHZlYzIgc3RhcnQ7XFxudW5pZm9ybSB2ZWMyIGVuZDtcXG51bmlmb3JtIHZlYzIgZGVsdGE7XFxudW5pZm9ybSB2ZWMyIHRleFNpemU7XFxuXFxuZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUsIGZsb2F0IHNlZWQpXFxue1xcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6ICsgc2VlZCwgc2NhbGUpKSAqIDQzNzU4LjU0NTMgKyBzZWVkKTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcbiAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXG5cXG4gICAgZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4MiksIDAuMCk7XFxuICAgIHZlYzIgbm9ybWFsID0gbm9ybWFsaXplKHZlYzIoc3RhcnQueSAtIGVuZC55LCBlbmQueCAtIHN0YXJ0LngpKTtcXG4gICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgYWJzKGRvdCh2VGV4dHVyZUNvb3JkICogdGV4U2l6ZSAtIHN0YXJ0LCBub3JtYWwpKSAvIGdyYWRpZW50Qmx1cikgKiBibHVyO1xcblxcbiAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspXFxuICAgIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgKyBkZWx0YSAvIHRleFNpemUgKiBwZXJjZW50ICogcmFkaXVzKTtcXG4gICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxuICAgICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxuICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgY29sb3IgLz0gdG90YWw7XFxuICAgIGNvbG9yLnJnYiAvPSBjb2xvci5hICsgMC4wMDAwMTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiLFhlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4obixyLG8saSl7dm9pZCAwPT09biYmKG49MTAwKSx2b2lkIDA9PT1yJiYocj02MDApLHZvaWQgMD09PW8mJihvPW51bGwpLHZvaWQgMD09PWkmJihpPW51bGwpLGUuY2FsbCh0aGlzLEVlLEJlKSx0aGlzLnVuaWZvcm1zLmJsdXI9bix0aGlzLnVuaWZvcm1zLmdyYWRpZW50Qmx1cj1yLHRoaXMudW5pZm9ybXMuc3RhcnQ9b3x8bmV3IHQuUG9pbnQoMCx3aW5kb3cuaW5uZXJIZWlnaHQvMiksdGhpcy51bmlmb3Jtcy5lbmQ9aXx8bmV3IHQuUG9pbnQoNjAwLHdpbmRvdy5pbm5lckhlaWdodC8yKSx0aGlzLnVuaWZvcm1zLmRlbHRhPW5ldyB0LlBvaW50KDMwLDMwKSx0aGlzLnVuaWZvcm1zLnRleFNpemU9bmV3IHQuUG9pbnQod2luZG93LmlubmVyV2lkdGgsd2luZG93LmlubmVySGVpZ2h0KSx0aGlzLnVwZGF0ZURlbHRhKCl9ZSYmKG4uX19wcm90b19fPWUpLG4ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLG4ucHJvdG90eXBlLmNvbnN0cnVjdG9yPW47dmFyIHI9e2JsdXI6e2NvbmZpZ3VyYWJsZTohMH0sZ3JhZGllbnRCbHVyOntjb25maWd1cmFibGU6ITB9LHN0YXJ0Ontjb25maWd1cmFibGU6ITB9LGVuZDp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ucHJvdG90eXBlLnVwZGF0ZURlbHRhPWZ1bmN0aW9uKCl7dGhpcy51bmlmb3Jtcy5kZWx0YS54PTAsdGhpcy51bmlmb3Jtcy5kZWx0YS55PTB9LHIuYmx1ci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5ibHVyfSxyLmJsdXIuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuYmx1cj1lfSxyLmdyYWRpZW50Qmx1ci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5ncmFkaWVudEJsdXJ9LHIuZ3JhZGllbnRCbHVyLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmdyYWRpZW50Qmx1cj1lfSxyLnN0YXJ0LmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnN0YXJ0fSxyLnN0YXJ0LnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnN0YXJ0PWUsdGhpcy51cGRhdGVEZWx0YSgpfSxyLmVuZC5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5lbmR9LHIuZW5kLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLmVuZD1lLHRoaXMudXBkYXRlRGVsdGEoKX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobi5wcm90b3R5cGUsciksbn0odC5GaWx0ZXIpLHFlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQsdC5wcm90b3R5cGUudXBkYXRlRGVsdGE9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnVuaWZvcm1zLmVuZC54LXRoaXMudW5pZm9ybXMuc3RhcnQueCx0PXRoaXMudW5pZm9ybXMuZW5kLnktdGhpcy51bmlmb3Jtcy5zdGFydC55LG49TWF0aC5zcXJ0KGUqZSt0KnQpO3RoaXMudW5pZm9ybXMuZGVsdGEueD1lL24sdGhpcy51bmlmb3Jtcy5kZWx0YS55PXQvbn0sdH0oWGUpLE5lPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQsdC5wcm90b3R5cGUudXBkYXRlRGVsdGE9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnVuaWZvcm1zLmVuZC54LXRoaXMudW5pZm9ybXMuc3RhcnQueCx0PXRoaXMudW5pZm9ybXMuZW5kLnktdGhpcy51bmlmb3Jtcy5zdGFydC55LG49TWF0aC5zcXJ0KGUqZSt0KnQpO3RoaXMudW5pZm9ybXMuZGVsdGEueD0tdC9uLHRoaXMudW5pZm9ybXMuZGVsdGEueT1lL259LHR9KFhlKSxXZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbixyLG8pe3ZvaWQgMD09PXQmJih0PTEwMCksdm9pZCAwPT09biYmKG49NjAwKSx2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1vJiYobz1udWxsKSxlLmNhbGwodGhpcyksdGhpcy50aWx0U2hpZnRYRmlsdGVyPW5ldyBxZSh0LG4scixvKSx0aGlzLnRpbHRTaGlmdFlGaWx0ZXI9bmV3IE5lKHQsbixyLG8pfWUmJih0Ll9fcHJvdG9fXz1lKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10O3ZhciBuPXtibHVyOntjb25maWd1cmFibGU6ITB9LGdyYWRpZW50Qmx1cjp7Y29uZmlndXJhYmxlOiEwfSxzdGFydDp7Y29uZmlndXJhYmxlOiEwfSxlbmQ6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiB0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZS5nZXRSZW5kZXJUYXJnZXQoITApO3RoaXMudGlsdFNoaWZ0WEZpbHRlci5hcHBseShlLHQsciksdGhpcy50aWx0U2hpZnRZRmlsdGVyLmFwcGx5KGUscixuKSxlLnJldHVyblJlbmRlclRhcmdldChyKX0sbi5ibHVyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuYmx1cn0sbi5ibHVyLnNldD1mdW5jdGlvbihlKXt0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuYmx1cj10aGlzLnRpbHRTaGlmdFlGaWx0ZXIuYmx1cj1lfSxuLmdyYWRpZW50Qmx1ci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aWx0U2hpZnRYRmlsdGVyLmdyYWRpZW50Qmx1cn0sbi5ncmFkaWVudEJsdXIuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudGlsdFNoaWZ0WEZpbHRlci5ncmFkaWVudEJsdXI9dGhpcy50aWx0U2hpZnRZRmlsdGVyLmdyYWRpZW50Qmx1cj1lfSxuLnN0YXJ0LmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuc3RhcnR9LG4uc3RhcnQuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudGlsdFNoaWZ0WEZpbHRlci5zdGFydD10aGlzLnRpbHRTaGlmdFlGaWx0ZXIuc3RhcnQ9ZX0sbi5lbmQuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGlsdFNoaWZ0WEZpbHRlci5lbmR9LG4uZW5kLnNldD1mdW5jdGlvbihlKXt0aGlzLnRpbHRTaGlmdFhGaWx0ZXIuZW5kPXRoaXMudGlsdFNoaWZ0WUZpbHRlci5lbmQ9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLEdlPW4sS2U9XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcbnVuaWZvcm0gdmVjMiBvZmZzZXQ7XFxudW5pZm9ybSB2ZWM0IGZpbHRlckFyZWE7XFxuXFxudmVjMiBtYXBDb29yZCggdmVjMiBjb29yZCApXFxue1xcbiAgICBjb29yZCAqPSBmaWx0ZXJBcmVhLnh5O1xcbiAgICBjb29yZCArPSBmaWx0ZXJBcmVhLnp3O1xcblxcbiAgICByZXR1cm4gY29vcmQ7XFxufVxcblxcbnZlYzIgdW5tYXBDb29yZCggdmVjMiBjb29yZCApXFxue1xcbiAgICBjb29yZCAtPSBmaWx0ZXJBcmVhLnp3O1xcbiAgICBjb29yZCAvPSBmaWx0ZXJBcmVhLnh5O1xcblxcbiAgICByZXR1cm4gY29vcmQ7XFxufVxcblxcbnZlYzIgdHdpc3QodmVjMiBjb29yZClcXG57XFxuICAgIGNvb3JkIC09IG9mZnNldDtcXG5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aChjb29yZCk7XFxuXFxuICAgIGlmIChkaXN0IDwgcmFkaXVzKVxcbiAgICB7XFxuICAgICAgICBmbG9hdCByYXRpb0Rpc3QgPSAocmFkaXVzIC0gZGlzdCkgLyByYWRpdXM7XFxuICAgICAgICBmbG9hdCBhbmdsZU1vZCA9IHJhdGlvRGlzdCAqIHJhdGlvRGlzdCAqIGFuZ2xlO1xcbiAgICAgICAgZmxvYXQgcyA9IHNpbihhbmdsZU1vZCk7XFxuICAgICAgICBmbG9hdCBjID0gY29zKGFuZ2xlTW9kKTtcXG4gICAgICAgIGNvb3JkID0gdmVjMihjb29yZC54ICogYyAtIGNvb3JkLnkgKiBzLCBjb29yZC54ICogcyArIGNvb3JkLnkgKiBjKTtcXG4gICAgfVxcblxcbiAgICBjb29yZCArPSBvZmZzZXQ7XFxuXFxuICAgIHJldHVybiBjb29yZDtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcblxcbiAgICB2ZWMyIGNvb3JkID0gbWFwQ29vcmQodlRleHR1cmVDb29yZCk7XFxuXFxuICAgIGNvb3JkID0gdHdpc3QoY29vcmQpO1xcblxcbiAgICBjb29yZCA9IHVubWFwQ29vcmQoY29vcmQpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkICk7XFxuXFxufVxcblwiLFllPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuLHIpe3ZvaWQgMD09PXQmJih0PTIwMCksdm9pZCAwPT09biYmKG49NCksdm9pZCAwPT09ciYmKHI9MjApLGUuY2FsbCh0aGlzLEdlLEtlKSx0aGlzLnJhZGl1cz10LHRoaXMuYW5nbGU9bix0aGlzLnBhZGRpbmc9cn1lJiYodC5fX3Byb3RvX189ZSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dDt2YXIgbj17b2Zmc2V0Ontjb25maWd1cmFibGU6ITB9LHJhZGl1czp7Y29uZmlndXJhYmxlOiEwfSxhbmdsZTp7Y29uZmlndXJhYmxlOiEwfX07cmV0dXJuIG4ub2Zmc2V0LmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldH0sbi5vZmZzZXQuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMub2Zmc2V0PWV9LG4ucmFkaXVzLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnJhZGl1c30sbi5yYWRpdXMuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMucmFkaXVzPWV9LG4uYW5nbGUuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMuYW5nbGV9LG4uYW5nbGUuc2V0PWZ1bmN0aW9uKGUpe3RoaXMudW5pZm9ybXMuYW5nbGU9ZX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsbiksdH0odC5GaWx0ZXIpLFFlPW4sVWU9XCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHZlYzQgZmlsdGVyQXJlYTtcXG5cXG51bmlmb3JtIHZlYzIgdUNlbnRlcjtcXG51bmlmb3JtIGZsb2F0IHVTdHJlbmd0aDtcXG51bmlmb3JtIGZsb2F0IHVJbm5lclJhZGl1cztcXG51bmlmb3JtIGZsb2F0IHVSYWRpdXM7XFxuXFxuY29uc3QgZmxvYXQgTUFYX0tFUk5FTF9TSVpFID0gMzIuMDtcXG5cXG4vLyBhdXRob3I6IGh0dHA6Ly9ieXRlYmxhY2tzbWl0aC5jb20vaW1wcm92ZW1lbnRzLXRvLXRoZS1jYW5vbmljYWwtb25lLWxpbmVyLWdsc2wtcmFuZC1mb3Itb3BlbmdsLWVzLTItMC9cXG5oaWdocCBmbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IHNlZWQpIHtcXG4gICAgY29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xcbiAgICBoaWdocCBmbG9hdCBkdCA9IGRvdChjbyArIHNlZWQsIHZlYzIoYSwgYikpLCBzbiA9IG1vZChkdCwgMy4xNDE1OSk7XFxuICAgIHJldHVybiBmcmFjdChzaW4oc24pICogYyArIHNlZWQpO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIGZsb2F0IG1pbkdyYWRpZW50ID0gdUlubmVyUmFkaXVzICogMC4zO1xcbiAgICBmbG9hdCBpbm5lclJhZGl1cyA9ICh1SW5uZXJSYWRpdXMgKyBtaW5HcmFkaWVudCAqIDAuNSkgLyBmaWx0ZXJBcmVhLng7XFxuXFxuICAgIGZsb2F0IGdyYWRpZW50ID0gdVJhZGl1cyAqIDAuMztcXG4gICAgZmxvYXQgcmFkaXVzID0gKHVSYWRpdXMgLSBncmFkaWVudCAqIDAuNSkgLyBmaWx0ZXJBcmVhLng7XFxuXFxuICAgIGZsb2F0IGNvdW50TGltaXQgPSBNQVhfS0VSTkVMX1NJWkU7XFxuXFxuICAgIHZlYzIgZGlyID0gdmVjMih1Q2VudGVyLnh5IC8gZmlsdGVyQXJlYS54eSAtIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZlYzIoZGlyLngsIGRpci55ICogZmlsdGVyQXJlYS55IC8gZmlsdGVyQXJlYS54KSk7XFxuXFxuICAgIGZsb2F0IHN0cmVuZ3RoID0gdVN0cmVuZ3RoO1xcblxcbiAgICBmbG9hdCBkZWx0YSA9IDAuMDtcXG4gICAgZmxvYXQgZ2FwO1xcbiAgICBpZiAoZGlzdCA8IGlubmVyUmFkaXVzKSB7XFxuICAgICAgICBkZWx0YSA9IGlubmVyUmFkaXVzIC0gZGlzdDtcXG4gICAgICAgIGdhcCA9IG1pbkdyYWRpZW50O1xcbiAgICB9IGVsc2UgaWYgKHJhZGl1cyA+PSAwLjAgJiYgZGlzdCA+IHJhZGl1cykgeyAvLyByYWRpdXMgPCAwIG1lYW5zIGl0J3MgaW5maW5pdHlcXG4gICAgICAgIGRlbHRhID0gZGlzdCAtIHJhZGl1cztcXG4gICAgICAgIGdhcCA9IGdyYWRpZW50O1xcbiAgICB9XFxuXFxuICAgIGlmIChkZWx0YSA+IDAuMCkge1xcbiAgICAgICAgZmxvYXQgbm9ybWFsQ291bnQgPSBnYXAgLyBmaWx0ZXJBcmVhLng7XFxuICAgICAgICBkZWx0YSA9IChub3JtYWxDb3VudCAtIGRlbHRhKSAvIG5vcm1hbENvdW50O1xcbiAgICAgICAgY291bnRMaW1pdCAqPSBkZWx0YTtcXG4gICAgICAgIHN0cmVuZ3RoICo9IGRlbHRhO1xcbiAgICAgICAgaWYgKGNvdW50TGltaXQgPCAxLjApXFxuICAgICAgICB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gcmFuZG9taXplIHRoZSBsb29rdXAgdmFsdWVzIHRvIGhpZGUgdGhlIGZpeGVkIG51bWJlciBvZiBzYW1wbGVzXFxuICAgIGZsb2F0IG9mZnNldCA9IHJhbmQodlRleHR1cmVDb29yZCwgMC4wKTtcXG5cXG4gICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuXFxuICAgIGRpciAqPSBzdHJlbmd0aDtcXG5cXG4gICAgZm9yIChmbG9hdCB0ID0gMC4wOyB0IDwgTUFYX0tFUk5FTF9TSVpFOyB0KyspIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCkgLyBNQVhfS0VSTkVMX1NJWkU7XFxuICAgICAgICBmbG9hdCB3ZWlnaHQgPSA0LjAgKiAocGVyY2VudCAtIHBlcmNlbnQgKiBwZXJjZW50KTtcXG4gICAgICAgIHZlYzIgcCA9IHZUZXh0dXJlQ29vcmQgKyBkaXIgKiBwZXJjZW50O1xcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHApO1xcblxcbiAgICAgICAgLy8gc3dpdGNoIHRvIHByZS1tdWx0aXBsaWVkIGFscGhhIHRvIGNvcnJlY3RseSBibHVyIHRyYW5zcGFyZW50IGltYWdlc1xcbiAgICAgICAgLy8gc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG5cXG4gICAgICAgIGlmICh0ID4gY291bnRMaW1pdCl7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgY29sb3IgLz0gdG90YWw7XFxuICAgIC8vIHN3aXRjaCBiYWNrIGZyb20gcHJlLW11bHRpcGxpZWQgYWxwaGFcXG4gICAgLy8gY29sb3IucmdiIC89IGNvbG9yLmEgKyAwLjAwMDAxO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCIsWmU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0LG4scixvKXt2b2lkIDA9PT10JiYodD0uMSksdm9pZCAwPT09biYmKG49WzAsMF0pLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPS0xKSxlLmNhbGwodGhpcyxRZSxVZSksdGhpcy5jZW50ZXI9bix0aGlzLnN0cmVuZ3RoPXQsdGhpcy5pbm5lclJhZGl1cz1yLHRoaXMucmFkaXVzPW99ZSYmKHQuX19wcm90b19fPWUpLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZSYmZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQ7dmFyIG49e2NlbnRlcjp7Y29uZmlndXJhYmxlOiEwfSxzdHJlbmd0aDp7Y29uZmlndXJhYmxlOiEwfSxpbm5lclJhZGl1czp7Y29uZmlndXJhYmxlOiEwfSxyYWRpdXM6e2NvbmZpZ3VyYWJsZTohMH19O3JldHVybiBuLmNlbnRlci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy51Q2VudGVyfSxuLmNlbnRlci5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy51Q2VudGVyPWV9LG4uc3RyZW5ndGguZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudVN0cmVuZ3RofSxuLnN0cmVuZ3RoLnNldD1mdW5jdGlvbihlKXt0aGlzLnVuaWZvcm1zLnVTdHJlbmd0aD1lfSxuLmlubmVyUmFkaXVzLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuaWZvcm1zLnVJbm5lclJhZGl1c30sbi5pbm5lclJhZGl1cy5zZXQ9ZnVuY3Rpb24oZSl7dGhpcy51bmlmb3Jtcy51SW5uZXJSYWRpdXM9ZX0sbi5yYWRpdXMuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5pZm9ybXMudVJhZGl1c30sbi5yYWRpdXMuc2V0PWZ1bmN0aW9uKGUpeyhlPDB8fGU9PT0xLzApJiYoZT0tMSksdGhpcy51bmlmb3Jtcy51UmFkaXVzPWV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQucHJvdG90eXBlLG4pLHR9KHQuRmlsdGVyKTtyZXR1cm4gZS5BZGp1c3RtZW50RmlsdGVyPW8sZS5BZHZhbmNlZEJsb29tRmlsdGVyPXAsZS5Bc2NpaUZpbHRlcj1nLGUuQmV2ZWxGaWx0ZXI9eSxlLkJsb29tRmlsdGVyPUYsZS5CdWxnZVBpbmNoRmlsdGVyPXcsZS5Db2xvck1hcEZpbHRlcj1PLGUuQ29sb3JSZXBsYWNlRmlsdGVyPVIsZS5Db252b2x1dGlvbkZpbHRlcj1rLGUuQ3Jvc3NIYXRjaEZpbHRlcj1CLGUuQ1JURmlsdGVyPU4sZS5Eb3RGaWx0ZXI9SyxlLkRyb3BTaGFkb3dGaWx0ZXI9VSxlLkVtYm9zc0ZpbHRlcj1ILGUuR2xpdGNoRmlsdGVyPWVlLGUuR2xvd0ZpbHRlcj1yZSxlLkdvZHJheUZpbHRlcj1zZSxlLkthd2FzZUJsdXJGaWx0ZXI9YSxlLk1vdGlvbkJsdXJGaWx0ZXI9Y2UsZS5NdWx0aUNvbG9yUmVwbGFjZUZpbHRlcj1wZSxlLk9sZEZpbG1GaWx0ZXI9Z2UsZS5PdXRsaW5lRmlsdGVyPXllLGUuUGl4ZWxhdGVGaWx0ZXI9Q2UsZS5SYWRpYWxCbHVyRmlsdGVyPXplLGUuUmVmbGVjdGlvbkZpbHRlcj1UZSxlLlJHQlNwbGl0RmlsdGVyPVBlLGUuU2hvY2t3YXZlRmlsdGVyPWplLGUuU2ltcGxlTGlnaHRtYXBGaWx0ZXI9SWUsZS5UaWx0U2hpZnRGaWx0ZXI9V2UsZS5UaWx0U2hpZnRBeGlzRmlsdGVyPVhlLGUuVGlsdFNoaWZ0WEZpbHRlcj1xZSxlLlRpbHRTaGlmdFlGaWx0ZXI9TmUsZS5Ud2lzdEZpbHRlcj1ZZSxlLlpvb21CbHVyRmlsdGVyPVplLGV9KHt9LFBJWEkpO09iamVjdC5hc3NpZ24oUElYSS5maWx0ZXJzLHRoaXM/dGhpcy5fX2ZpbHRlcnM6X19maWx0ZXJzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpeGktZmlsdGVycy5qcy5tYXBcbiJdfQ==
